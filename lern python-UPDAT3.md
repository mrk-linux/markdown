# **_vscode_**

- [**_vscode_**](#vscode)
- [عمل گر مقایسه ای](#عمل-گر-مقایسه-ای)
- [عملگرهای انتساب](#عملگرهای-انتساب)
- [عملگرهای منطقی](#عملگرهای-منطقی)
- [**split**](#split)
- [join](#join)
- [کاراکتر بک‌اسلش (\\)](#کاراکتر-بکاسلش-)

- [**تکه بندی**](#تکه-بندی)
    - [(f-string)فرمت دهی رشته با](#f-stringفرمت-دهی-رشته-با)

- [**لیست**](#لیست)
    - [ویژگی‌های کلیدی:](#ویژگیهای-کلیدی)
    - [دستورات پرکاربرد](#دستورات-پرکاربرد)

- [**دیکشنری**](#دیکشنری)
  - [تعریف دیکشنری](#تعریف-دیکشنری)
  - [ویژگی‌های کلیدی:](#ویژگیهای-کلیدی-1)
  - [روش‌های ایجاد دیکشنری:](#روشهای-ایجاد-دیکشنری)
  - [متدهای مهم:](#متدهای-مهم)
  - [مثال پیشرفته:](#مثال-پیشرفته)

- [**حلقه**](#حلقه)
  - [**انواع حلقه‌ها :**](#انواع-حلقهها-)
    - [1. حلقه `for`](#1-حلقه-for-برای-تکرار-روی-دنبالهها)
    - [2. حلقه `while`](#2-حلقه-while-برای-تکرار-شرطی)
  - [**کنترل جریان حلقه‌ها**](#کنترل-جریان-حلقهها)
    - [1. `break` (خروج از حلقه)](#1-break-خروج-از-حلقه)
    - [2. `continue` (رد کردن یک تکرار)](#2-continue-رد-کردن-یک-تکرار)
    - [3. `else` (پس از اتمام حلقه)](#3-else-پس-از-اتمام-حلقه)
    - [4. enumerate](#4-enumerate)
  - [تکنیک‌های پیشرفته](#تکنیکهای-پیشرفته)
  
  - [نکات مهم:](#نکات-مهم)
  - [مثال کاربردی:](#مثال-کاربردی)

- [zip](#zip)

- [**تابع**](#تابع)
    - [تعریف تابع](#1-برای-تعریف-تابع-از-کلمه-کلیدی-def-استفاده-میشود)
    - [انواع پارامترها](#2انواع-پارامترها)
    - [return](#3-return)
    - [توابع بازگشتی (Recursive)](#4-توابع-بازگشتی-recursive)
    - [توابع لامبدا (Lambda)](#5-توابع-لامبدا-lambda)
    - [دکوراتورها (Decorators)](#6-دکوراتورها-decorators)
    - [مثال](#مثال)
    - [نکات مهم:](#نکات-مهم-1)

- [**یادداشت تابع (function annotation)**](#یادداشت-تابع-function-annotation)
  - [مثال](#مثال-1)

- [**توابع لامبدا**](#توابع-لامبدا)
  - [1. ساختار توابع لامدا:](#1-ساختار-توابع-لامدا)
  - [2. دستورات لامدا](#2-دستورات-لامدا)
    - [1. تابع map:](#1-تابع-map)
    - [2. تابع filter:](#2-تابع-filter)
    - [3. تابع reduce:](#3-تابع-reduce)
    - [4. تابع sorted:](#4-تابع-sorted)
- [pass](#pass)
- [DocString](#docstring)

- [**تکرار (Iteration)**](#تکرار-iteration)
  - [1. حلقه `for` ](#1-حلقه-for--تکرار-بر-روی-عناصر-یک-دنباله)
  - [2. حلقه `while`](#2-حلقه-while--تکرار-تا-زمانی-که-شرط-برقرار-است)
  - [3. کنترل جریان حلقه‌ها (`break`, `continue`, `else`)](#3-کنترل-جریان-حلقهها-break-continue-else)
  - [4. توابع تکرارپذیر (`range`, `enumerate`, `zip`)](#4-توابع-تکرارپذیر-range-enumerate-zip)
  - [نتیجه‌گیری](#نتیجهگیری)

- [**Decorator**](#decorator)
  - [دکوراتورهای استاندارد پایتون](#دکوراتورهای-استاندارد-پایتون)
  - [کاربردهای رایج دکوراتورها](#کاربردهای-رایج-دکوراتورها)
  - [فرم کلی](#فرم-کلی)
  - [مثال :](#مثال-)
  - [نکات مهم](#نکات-مهم-2)
  - [جمع‌بندی](#جمعبندی)

- [**ژنراتورها (Generators)**](#ژنراتورها-generators)
  - [1. ژنراتور](#1-ژنراتور)
  - [2. ساخت ژنراتور](#2-ساخت-ژنراتور)
    - [تابع ژنراتور (با `yield`)](#تابع-ژنراتور-با-yield)
  - [3. تفاوت ژنراتور با لیست معمولی](#3-تفاوت-ژنراتور-با-لیست-معمولی)
  - [4. مثال](#4-مثال)
    - [مثال های بیشتر](#مثال-های-بیشتر)
  - [5. تفاوت `yield` و `return`](#5-تفاوت-yield-و-return)
  - [خلاصه](#خلاصه)

- [**متد لیست**](#متت-های-لیست)
  -  [متدهای اضافه کردن عناصر](#۱-متدهای-اضافه-کردن-عناصر)
  -  [متد حذف عتاصر](#۲-متدهای-حذف-عناصر)
  -  [متد جست و جو](#۳-متدهای-جستجو-و-اطلاعات)
  -  [متد مرتب سازی](#۴-متدهای-مرتبسازی-و-تغییر-ترتیب)
  -  [متد کپی و ایجاد لیست جدید](#۵-متدهای-کپی-و-ایجاد-لیست-جدید)
  -  [سایر متد ها](#۶-سایر-متدهای-مفید)
  -  [جمع بندی](#جمع-بندی)

- [**متد های تاپل و مجموعه ها**](#متد-های-تاپل-و-مجموعه-ها)
  - [متد تاپل ها](#متدهای-تاپل-tuple-methods)
  - [متد مجموعه ها](#متدهای-مجموعه-set-methods)

- [**متد های دیکشنری**](#متد-های-دیکشنری)
  - [متد های اصلی دیکشنری](#متدهای-اصلی-دیکشنری)
  - [متدهای بررسی و کاربردهای پیشرفته](#متدهای-بررسی-و-کاربردهای-پیشرفته)
  - [تفاوت `copy()` و `deepcopy()`](#تفاوت-copy-و-deepcopy)
  - [جمع‌بندی ](#-جمعبندی-متدهای-دیکشنری)

- [**متد رشته**](#متد-رشته)
  - [تبدیل حروف و نرمال‌سازی](#1-تبدیل-حروف-و-نرمالسازی)
  - [جستجو و بررسی محتوا](#2-جستجو-و-بررسی-محتوا)
  - [اصلاح و فرمت‌دهی متن](#3-اصلاح-و-فرمتدهی-متن)

- [**عملگر والروس**](#عملگر-والروس)
  - [کاربرد ها](#کاربرد-اصلی)
  - [مثال‌های کاربردی](#مثالهای-کاربردی)
  - [محدودیت‌ها و نکات مهم](#محدودیتها-و-نکات-مهم)
  
- [**تابع open( )**](#تابع-open)
  - [پارامترهای تابع](#پارامترهای-تابع-open)
    - [file](#1-پارامتر-file)
    - [mode](#2-پارامتر-mode)
    - [buffering](#3-پارامتر-buffering)
    - [encoding](#4-پارامتر-encoding)
    - [errors](#5-پارامتر-errors)
    - [newline](#6-پارامتر-newline)
    - [closefd](#7-پارامتر-closefd)
    - [opener](#8-پارامتر-opener)
  - [روش‌های کار با فایل باز شده](#روشهای-کار-با-فایل-باز-شده)
  - [مثال‌](#مثالهای-تابع-open)
  - [نکات مهم](#نکات-مهم-و-بهترین-روشها)
- 
- 

# عمل گر مقایسه ای

- == : equal
- != : not equal
- .> : greatel than //همان
- < : less than
- .>= : greater than or equal to //کوچیک تر مساوی
- <= : less than or equal to

# عملگرهای انتساب

- += x=x+2
- -= x=x-2
- *= x=x*2
- /= x=x/2
- %= x=x%2 //باقی مانده
- //= x=x//2
- **= x=x**2 //توان 2

```
    x = 4
    x += 2;
    print(x);       //پرینت می کنه 6
```

# عملگرهای منطقی

![alt text](<picture-lening/عملگرهای منطقی.png>)

- ما می توان با دستور + دو تا رشته را به هم جمع کنیم

  > print("x"+"y")

- دستور را چندین بار تکرار میکند

  > print(4\*"alireza")

- اخرین رقم ان عدد را نشان می دهد
  print(هر عددی %10)

- به میزانی که عدد گذاشتیم عدد را رند می کند

  > print(round(motegaier, 2))

- متوجه میشیم که یک متغیر جزو کدام نوع داده هست

  > print(isinstance(نوع متغیر , متغیر))

- تعداد تکرار را میشمرد

  > [رشته].count()

- فضای خالی از سمت راست را پاک می کند

  > [رشته].rstrip

- پیدا می کند از داخل رشته

  > [رشته].find

- یک کارکتر چند بار تکرار شده

  > تابع.count('یک کارکتر از تابع')

- برسی می کند که یک تابع با یک کارکتر خاص به اتمام رسیده است یا خیر

  > تابع. endswith("کارکتر")

- برسی می کند که یک تابع با یک کارکتر خاص شروع شده یا خیر

  > تابع. startswith("کارکتر")

- کارکتر را پیدا میکند
- ایندکس ان (از سمت چپ شروع می شود)

  > تابع . find ('کارکتر')

- نشان میده که کل کارکتر فقط عدد است یا نه

  > تابع . isnumeric()

- > تابع . replace ('کارکتر که می خوایم عوض بشه ', 'کارکتری که جایگذاری بشه')

- اگر داخل پرانتز خالی باشد فاصله در نظر می گیرد ; فاصله های اضاقی از ابتدا و انتهای را پاک می کند

  > تابع . strip()

- از سمت چپ فقط پاک میکند

  > تابع . lreplace

- مقدار تکرار یک چیز را می شمارد

  > c . count(تابع)

- یونیکد

  > ord()

- مقادیر را مرتب می کند

  > sorted()

- نوع رشته را مشخص میکند
  > (type(رشته))

# **split**

- این دستور ترکیبی از دو عمل اصلی است که برای دریافت ورودی از کاربر و تقسیم آن به بخش‌های جداگانه استفاده می‌شود:

- .split()

  - متدی برای رشته‌ها که آنها را بر اساس جداکننده (پیش‌فرض: فاصله) تقسیم می‌کند

  - نتیجه یک لیست از زیررشته‌ها است

  ```py
  data = input("enter: ").split(',')
   ورودی: "علی,رضا,مریم"
   → ['علی', 'رضا', 'مریم']
  ```

# join

- دو تابع را به یک دیگر متصل می کند

```py
s = "*"
l + ["a" , "b" , "c"]
print(s.join(l))
===> a*b*c
```

# کاراکتر بک‌اسلش (\\)

- (\دستور) ----- کار این دستور لغو کردن دستورات است

- \n ------ می رود خط بعدی
- \\\ ----- c:\alireza\new ==> c:\alireza\\\new
- \t ------- یک تب فاصله می دهد
- اگر قبل رشته دستور (r')بزنیم تمام دستورات \ را لغو می کند
- \b ------ حرف قبلی را پاک می کند

# تکه بندی

- برای اینکه بتوانیم ایندکس یک رشته را بگیریم

  - (s[ایندکس])

- برای چاپ کردن یک بخشی از رشته

  - (رشته[ایندکس: ایندکس])
  - اگر در هر قسمت ایندکس نگذاریم تا اخر رشته را استفاده می کند

- طول گام را مشخص می کند

  - ([گام: ایندکس :ایندکس]رشته)

- (len(رشته)) سایز رشته را نشان می دهد

- (رشته[::]) رشته را معکوس می کند

### (f-string)فرمت دهی رشته با

```py
name = "alireza"
age = 18

msg =(
f"name: {name}\n"
f'age: {age}\n
     )

print(msg)

autput= name: alireza
       age:18
```

# لیست

لیست یک ساختار داده‌ی تغییرپذیر و ترتیبی در پایتون است که می‌تواند عناصر مختلف را ذخیره کند .

> my_list = [1, "دو", 3.0, True] # ایجاد لیست با انواع داده مختلف

### ویژگی‌های کلیدی:

1. تغییرپذیر (Mutable): محتوا قابل تغییر است
   > my_list[0] = 10 # تغییر اولین عنصر
2. ترتیبی (Ordered): ترتیب عناصر حفظ می‌شود
3. پشتیبانی از انواع داده مختلف:
   > mixed = [1, "text", 3.14, [1, 2]] # لیست در لیست

- `متدهای پرکاربرد`

```
1.  print(my_list[0])  # اولین عنصر (ایندکس 0)
2.  print(my_list[-1]) # آخرین عنصر
3. print(my_list[1:3])  # عناصر از ایندکس 1 تا 2
4. my_list.append(4)       # اضافه کردن به انتها
5. my_list.insert(1, 1.5)  # درج در موقعیت خاص
6. my_list.remove("دو")    # حذف مقدار خاص
7. popped = my_list.pop()  # حذف و بازگرداندن آخرین عنصر
8. len(my_list)      # طول لیست
9. my_list.sort()    # مرتب‌سازی
10. my_list.reverse() # معکوس کردن ترتیب
```

- `نکته`
  - با گذاشتن ستاره قبل از یک کارکتر کارکتر را تبدیل به لیست میکند

```py
a, b, *c = [1, 2, 3, 4, 5, 6]
print(a, b, c)

autput = 1      2       [3, 4, 5, 6]
```

### دستورات پرکاربرد

1. **reversed** = یکی از لیست ها را معکوس می کند

```python
x = ['Alice', 'Bob', 'Charlie']
y = [25, 30, 35]
for i, j in reversed(x,y):
   print(i)
```

2. **sorted**
   (به ترتیب حرف الف با)تمامی لیست را مرتب می کند

```python
x = ['Alice', 'Bob', 'Charlie']
y = [25, 30, 35]
for i, j in sorted(x):
    print(i)
```

3. **random**
   min + (random \* (max - min)) عدد رندوم در بازه ای که میخوایم تولید می کند

- random.uniform یک تابع از ماژول random است که برای تولید اعداد تصادفی با توزیع یکنواخت پیوسته (Continuous Uniform Distribution) استفاده می‌شود. این تابع یک عدد اعشاری تصادفی در بازه مشخص شده ([a, b]) برمی‌گرداند که همه مقادیر در این بازه احتمال یکسانی دارند.

- تفاوت random.uniform با random.random:

  - random.random() فقط اعداد بین ۰.۰ تا ۱.۰ تولید می‌کند.

  - random.uniform(a, b) اعداد بین a تا b (شامل a و b) تولید می‌کند.

```python
import random

# با random.random
rand1 = random.random()  # مثلاً 0.74321

# با random.uniform
rand2 = random.uniform(5, 10)  # مثلاً 7.8321
```

```python
#مثال
#(تولید عدد رندوم در بازه بیت 5 تا 10 )
from random import random
for _ in range(10):
    print(5 + (random() * (10 - 5)))

#مثال 2
from random import random
for _ in range(10):
    print(5 + (random() * (10)))

#random uniform

from random import random, uniform
for _ in range(10):
    print(uniform(5,10))

#تولید عدد رندوم intger

from random import randint
for _ in range(10):
    print(randint(5, 16))

#تولید عدد رندوم با طول گام

from random import randrange
for _ in range(10):
    print(randrange(5, 50, 3))


#از بازه موجود به صورت رندوم یک را انتخاب می کند
from random import choice
x = ["a", "b", "c","d"]
for _ in range(10):
    print(choice(x))

#یک زیر لیست از لیست درست می کند

from random import sample
x = ["a", "b", "c","d"]
print(sample(x, 2))
print(x)
```

`نکته:`
اگر می خواهیم بعد از تولید یک زیر لیست , زیر لیست تغیر نکند از دستور
(**seed**) استقاده می کنیم

```python
from random import sample, seed
x = ["a", "b", "c","d"]
seed(10)
print(sample(x, 2))
print(x)
```

4.  **shuffle**
    بور می زند یعنی لبست من را شانسی بور می زند

```python
from random import shuffle
x = ["a", "b", "c","d"]
shuffle(x)
print(x)
```

# دیکشنری

## تعریف دیکشنری

- دیکشنری (Dictionary) یک ساختار داده‌ی **تغییرپذیر**، **نامرتب** و **ایندکس‌گذاری شده با کلید** در پایتون است که داده‌ها را به صورت جفت‌های `کلید: مقدار` ذخیره می‌کند.

```python
my_dict = {"name": "علی", "age": 25, "city": "تهران"}
```

## ویژگی‌های کلیدی:

1. **تغییرپذیر (Mutable)**: مقادیر قابل تغییر هستند
2. **نامرتب (Unordered)**: ترتیب عناصر حفظ نمی‌شود (تا پایتون 3.6)
3. **عدم اجازه کلید تکراری**: هر کلید فقط یک بار می‌تواند وجود داشته باشد

## روش‌های ایجاد دیکشنری:

1. روش مستقیم:

   ```python
   person = {"name": "رضا", "age": 30}
   ```

2. استفاده از تابع `dict()`:

   ```python
   person = dict(name="نازنین", age=28)
   ```

3. از لیست تاپل‌ها:
   ```python
   pairs = [("one", 1), ("two", 2)]
   numbers = dict(pairs)
   ```

## متدهای مهم:

- اگر بخواهیم یک متغیر تعریف کنیم که هیچ متغیر خاصی ندارد از \***\*none type\*\*** استفاده می کنیم
  تابع = none

```python
keys = person.keys()    # لیست کلیدها
values = person.values()  # لیست مقادیر
items = person.items()   # لیست جفت‌های کلید-مقدار
```

## مثال پیشرفته:

```python
students = {
    1001: {"name": "علی", "grades": [18, 20, 16]},
    1002: {"name": "زهرا", "grades": [19, 17, 20]}
}

# محاسبه میانگین نمرات
for student_id, info in students.items():
    avg = sum(info["grades"]) / len(info["grades"])
    print(f"{info['name']}: {avg:.2f}")
```

# حلقه

## انواع حلقه‌ها :

### 1. حلقه `for` (برای تکرار روی دنباله‌ها)

```python
for item in sequence:
    # دستورات
```

مثال:

```python
fruits = ["سیب", "پرتقال", "موز"]
for fruit in fruits:
    print(fruit)
```

### 2. حلقه `while` (برای تکرار شرطی)

```python
while condition:
    # دستورات
```

مثال:

```python
count = 0
while count < 5:
    print(count)
    count += 1
```

مثال 2:

```
n = int(input("x = "))
while n < 100:
    if n % 2 == 0 :
     print(n)
n += 1
اعداد زوج را چاپ می کند
```

## کنترل جریان حلقه‌ها

### 1. `break` (خروج از حلقه)

```python
for num in range(10):
    if num == 5:
        break
    print(num)
```

```python
n = float(input("n:"))
m = n
while True:
    s = input("do tou cantinue?")
    if s.lower() == "no":
        break
    n = float(input("n:"))
    if n < m :
        m = n
        print(m,"min:")
```

### 2. `continue` (رد کردن یک تکرار)

```python
for num in range(10):
    if num % 2 == 0:
        continue
    print(num)  # فقط اعداد فرد
```

### 3. `else` (پس از اتمام حلقه)

```python
for num in range(3):
    print(num)
else:
    print("حلقه کامل اجرا شد")
```

```python
i = 0
while i <10:
   i += 1
   if i % 3 == 0:
       break
    print(i)
else:
    print("ok")
autput
1
2
```

```python
n = int(input("n:"))
i = 2
if n > 1:
    while i < n:
        if n % i == 0:
            print(n,"is nat prime number")
            break
        i += 1
    else:
        print(n, "not prime number")
else:
    print(n,"is a not prime number")
#برسی می کند عدد اول هست یا نه
```

### 4. enumerate

تابع **enumerate** در پایتون به شما اجازه می‌دهد تا همزمان به اندیس و مقدار عناصر یک لیست دسترسی داشته باشید.

```python
  l = ["a", "b", "c", "d"]
  for i ,j enumerate(l):
     print(i, ":", j)

  autput
  0 : a
  1 : b
  3 : c
  4 : d
```

## تکنیک‌های پیشرفته

### 1. حلقه با `range()`

اگر بخواهیم در حلقه (for )یک رنج تعریف کنیم از دستور **range**استفاده می کنیم

- range(طول گام , بازه )

```python
for i in range(5):       # 0 تا 4
for i in range(2, 6):    # 2 تا 5
for i in range(1, 10, 2): # 1 تا 9 با گام 2
```

مثال :

```python
   l = input("name:").split("-")
   print(l)
   for i in range(0, len(l)):
     print(i, L[i])
```

### 2. حلقه روی دیکشنری

```python
person = {"name": "علی", "age": 30}

for key in person:         # کلیدها
for value in person.values(): # مقادیر
for key, value in person.items(): # جفت‌ها
```

### 3. حلقه‌های تو در تو

```python
for i in range(3):
    for j in range(2):
        print(f"({i}, {j})")
```

### 4. فهرست‌سازی (List Comprehension)

```python
squares = [x**2 for x in range(10)]
```

## نکات مهم:

- از حلقه `for` برای تکرار روی اشیاء قابل پیمایش استفاده کنید
- از حلقه `while` وقتی تعداد تکرارها نامشخص است استفاده کنید
- از `break` و `continue` برای کنترل جریان استفاده کنید
- `range()` یک دنباله اعداد ایجاد می‌کند

## مثال کاربردی:

```python
# محاسبه فاکتوریل
n = 5
factorial = 1
for i in range(1, n+1):
    factorial *= i
print(f"!{n} = {factorial}")
```

# zip

دستور zip در پایتون دو یا چند لیست را گرفته و آن‌ها را به صورت زوج‌های (tuple) ترکیب می‌کند.

```python
x = ['Alice', 'Bob', 'Charlie']
y = [25, 30, 35]
for i, j in zip(x,y):
   print("name", i, "age", j)
```

# تابع

تابع (Function) در پایتون یک بلوک کد قابل استفاده مجدد است که یک کار خاص را انجام می‌دهد. توابع به سازماندهی کد، جلوگیری از تکرار و افزایش خوانایی کمک می‌کنند.

### 1. برای تعریف تابع از کلمه کلیدی `def` استفاده می‌شود:

```python
def نام_تابع(پارامترها):
    # بدنه تابع
    return نتیجه  # اختیاری
```

---

### **2.انواع پارامترها**

#### **الف) پارامترهای معمولی**

```python
def add(a, b):
    return a + b

print(add(3, 5))  # خروجی: 8
```

#### **ب) پارامترهای نام‌دار (Keyword Arguments)**

```python
def person_info(name, age):
    print(f"نام: {name}, سن: {age}")

person_info(age=25, name="رضا")  # ترتیب مهم نیست!
```

#### **ج) پارامترهای نامحدود (`*args` و `**kwargs`)\*\*

- `*args` برای دریافت لیستی از مقادیر:

  ```python
  def sum_all(*numbers):
      return sum(numbers)

  print(sum_all(1, 2, 3))  # خروجی: 6
  ```

- `**kwargs` برای دریافت دیکشنری از پارامترهای نام‌دار:

  ```python
  def show_info(**details):
      for key, value in details.items():
          print(f"{key}: {value}")

  show_info(name="مریم", age=30, city="تهران")
  ```

---

### **3. return**

اگر ما از تابع استفاده کنیم و دستور(return) را استفاده نکنیم و بعد تابع را صدا بزنیم اخر کلمه `none` را چاپ می کند

- همیشه لازم نیست از (return)استفاده شود

```py
def f():
    x = int(input("x :"))
    print(2 * x + 1)
f()
```

### **4. توابع بازگشتی (Recursive)**

تابعی که خودش را فراخوانی می‌کند.  
**مثال: محاسبه فاکتوریل:**

```python
def factorial(n):
    return 1 if n == 1 else n * factorial(n - 1)

print(factorial(5))  # 120
```
```py
#تابع عادی
def fact(x):
  f = 1
    for i in range(1, x+1):
      f += i
    return f
#تابع بازگشتی
def rec_fact(x):
  if x == 0 or x == 1:
    return 1
  return x * fact(x -1)
```

---

### **5. توابع لامبدا (Lambda)**

توابع کوچک و بی‌نام که با `lambda` تعریف می‌شوند:

```python
square = lambda x: x ** 2
print(square(4))  # 16
```

**کاربرد در `map` و `filter`:**

```python
numbers = [1, 2, 3]
squared = list(map(lambda x: x ** 2, numbers))  # [1, 4, 9]
```

---

### **6. دکوراتورها (Decorators)**

برای تغییر رفتار تابع بدون تغییر کد اصلی استفاده می‌شوند:

```python
def logger(func):
    def wrapper(*args, **kwargs):
        print(f"اجرای تابع {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@logger
def greet(name):
    print(f"سلام {name}!")

greet("علی")  # ابتدا "اجرای تابع greet" چاپ می‌شود.
```

---

### مثال

```py
f(x)= 2x+1
def f(x):
    return 2 x + 1
print(f(1))

#مثال 2:
def f(x):
    return 2 * x + 1
y = int(input("y :"))
f(y)
print(f(y))
#مثال 3:
def f():
    x = int(input("x :"))
    return 2 * x + 1
print(f())
```

---

### **نکات مهم:**

1. نام تابع باید توصیفی باشد (مثل `calculate_area` به جای `func1`).
2. از توابع برای تقسیم کد به بخش‌های منطقی استفاده کنید.
3. توابع باید تا حد امکان مستقل از متغیرهای خارجی باشند.

# یادداشت تابع (function annotation)

- در مقابل، پایتون به عنوان یک زبان داینامیک تایپ، به شما اجازه می‌دهد نوع پارامترها را مشخص نکنید و ارسال نوع داده اشتباه را در زمان اجرا تشخیص می‌دهد. این موضوع گاهی اوقات می‌تواند مشکل‌ساز باشد، زیرا ممکن است خطای نوع داده تا زمان اجرای برنامه مشخص نشود.

- برای حل این مشکل، پایتون از یادداشت تابع (Function Annotations) استفاده می‌کند. با استفاده از یادداشت تابع، می‌توان نوع پارامترها و نوع خروجی تابع را مشخص کرد.

- نکته مهم این است که یادداشت تابع در زمان اجرای عادی پایتون، هیچ تاثیری در عملکرد برنامه ندارد و صرفا برای راهنمایی برنامه‌نویس و ابزارهای توسعه مانند IDEها و Linterها استفاده می‌شود. برای مثال، PyCharm با استفاده از یادداشت تابع، می‌تواند خطاهای نوع داده را قبل از اجرا به شما نشان دهد.

- برای تشخیص خطاهای نوع داده در زمان اجرا، می‌توانید از ماژول mypy استفاده کنید. این ماژول با بررسی یادداشت تابع، خطاهای نوع داده را در زمان اجرا شناسایی می‌کند.

- نحوه تعریف نوع پارامترها با استفاده از یادداشت تابع به این صورت است که بعد از نام پارامتر، دو نقطه قرار داده و سپس نوع داده مورد نظر را می‌نویسیم.

- برای تعریف نوع خروجی تابع، باید بین دو نقطه و پرانتز تابع، یک فلش به سمت راست (->) قرار داده و سپس نوع داده خروجی را بنویسیم.

- همچنین می‌توان برای پارامترهای تابع، مقادیر پیش‌فرض تعیین کرد. در این صورت، اگر هنگام فراخوانی تابع، مقداری برای پارامتر ارسال نشود، از مقدار پیش‌فرض استفاده خواهد شد.

- برای مشاهده یادداشت تابع، می‌توان از **annotations** استفاده کرد.

- در نهایت، می‌توان از انواع داده مختلف مانند دیکشنری، لیست و تاپل در یادداشت تابع استفاده کرد.

- به طور کلی، استفاده از یادداشت تابع در پایتون، می‌تواند به خوانایی کد و جلوگیری از خطاهای نوع داده کمک کند.

## مثال

```py
#مثال ۱: تابع ساده با ورودی و خروجی عددی
def func(x: int, y: int, z: int) -> int:
    return x + y + z

print(func(1, 2, 3))
#در این مثال، تابع func سه پارامتر ورودی از نوع int دریافت می‌کند و خروجی آن نیز از نوع int است.

# مثال ۲: تابع با مقدار پیش‌فرض
def func(x: int = 10, y: int = 9, z: int = 5):
print(x, y, z)

func()
#در این مثال، برای هر یک از پارامترهای تابع func یک مقدار پیش‌فرض تعیین شده است. اگر تابع بدون ارسال آرگومان فراخوانی شود، از مقادیر پیش‌فرض استفاده خواهد شد.
#مثال ۳: تابع با نوع داده دیکشنری
def func(x: int, y: int, z: dict):
print(x)
print(y)
print(z)

func(1, 9, {})
#در این مثال، پارامتر z از نوع dict (دیکشنری) است.
# مثال ۴: تابع با نوع داده تاپل
def func(x: int, y: int, z: int) -> tuple:
    return (x+y+z, x, y, z)

print(func(1, 2, 5))
#در این مثال، نوع خروجی تابع func یک tuple (تاپل) است که شامل جمع سه عدد و خود اعداد می‌شود.


#    نکته: در تمامی این مثال‌ها، اگر نوع داده اشتباهی به تابع ارسال شود (مثلاً به جای عدد، رشته ارسال شود)، در زمان اجرای عادی پایتون خطایی رخ نمی‌دهد. اما اگر از ابزار mypy یا IDEهایی مانند PyCharm استفاده کنید، این خطاها قبل از اجرا یا در زمان اجرا شناسایی خواهند شد.
```

# توابع لامبدا

- لامبدا و کاربرد آن (map، filter، reduce و sorted)
- مفهوم توابع لامدا به عنوان توابع ناشناس و مختصر در پایتون توضیح داده می‌شود. این توابع برای مواقعی که نیاز به یک تابع کوچک و یکبار مصرف داریم، مفید هستند.

## 1. ساختار توابع لامدا:

توابع لامدا با استفاده از کلمه کلیدی lambda تعریف می‌شوند و ساختار آنها به صورت زیر است:
lambda arguments: expression

- توابع لامبدا توابع ناشناسی هستند که در یک خط نوشته می‌شوند و اسم ندارند. [1، 2] این توابع برای زمانی که به تابعی کوچک و یکبار مصرف نیاز دارید مفید هستند.

- **نحوه نوشتن یک تابع لامبدا:**

ابتدا کلمه کلیدی "لامبدا" را می‌نویسیم. سپس ورودی‌های تابع را با کاما از هم جدا می‌کنیم. بعد از ورودی‌ها، دو نقطه قرار می‌دهیم و در جلوی دو نقطه عبارت یا بدنه تابع را می‌نویسیم. نیازی به نوشتن دستور "ریترن" نیست زیرا به طور خودکار عبارت بعد از دو نقطه را برمی‌گرداند.

- ### Arguments: ورودی‌های تابع که با کاما از هم جدا می‌شوند.

- ### Expression: عبارتی که قرار است توسط تابع اجرا شود و نتیجه آن برگردانده شود.

  **نکات مهم:**

      1. توابع لامدا نیازی به نام ندارند.

      2. بدنه این توابع فقط شامل یک عبارت است.

      3. نیازی به استفاده از دستور return نیست، زیرا عبارت به صورت خودکار برگردانده می‌شود.

  **کاربردهای توابع لامدا:**

-توابع لامدا در کنار توابع و نوع‌های داخلی پایتون مانند map، filter، reduce و sorted کاربردهای فراوانی دارند.

## 2. دستورات لامدا

### 1. تابع map:

-تابع map دو آرگومان دریافت می‌کند: یک تابع و یک لیست. این تابع، عناصر لیست را یکی‌یکی به تابع ارسال می‌کند و نتیجه هر عنصر را در لیست جدیدی قرار می‌دهد.

```py
new_list = list(map(lambda x: x**2, my_list))

#در این مثال، هر عنصر لیست my_list به توان دو رسانده شده و نتیجه در لیست new_list قرار می‌گیرد.
```

### 2. تابع filter:

- تابع filter نیز دو آرگومان دریافت می‌کند: یک تابع و یک لیست. این تابع، عناصر لیست را یکی‌یکی به تابع ارسال می‌کند و اگر نتیجه تابع True باشد، عنصر را در لیست جدیدی قرار می‌دهد و در غیر این صورت آن را حذف می‌کند.

```py
new_list = list(filter(lambda x: x > 5, my_list))

#در این مثال، فقط عناصری از لیست my_list که بزرگتر از 5 هستند در لیست new_list قرار می‌گیرند.
```

### 3. تابع reduce:

- تابع reduce دو ورودی دریافت می‌کند: یک تابع و یک لیست. این تابع، دو عنصر اول لیست را به تابع ارسال می‌کند و نتیجه آن را با عنصر سوم لیست به تابع ارسال می‌کند و این کار را تا آخرین عنصر لیست ادامه می‌دهد.

```py
from functools import reduce

sum_of_list = reduce(lambda x, y: x + y, my_list)

#در این مثال، reduce جمع همه عناصر لیست my_list را محاسبه می‌کند.
```

### 4. تابع sorted:

- تابع sorted یک لیست را به عنوان ورودی دریافت می‌کند و یک لیست مرتب شده بر می‌گرداند. این تابع همچنین می‌تواند یک آرگومان اختیاری به نام key دریافت کند که یک تابع است و برای مرتب‌سازی عناصر لیست استفاده می‌شود.

```py
sorted_list = sorted(my_list, key=lambda x: len(x))

#در این مثال، sorted لیست my_list را بر اساس طول رشته‌ها مرتب می‌کند.
```

---

```python
lambda x: x ** 2
#در این مثال، تابع یک ورودی (x) می‌گیرد و آن را به توان دو می‌رساند.
```

**کاربردهای لامبدا:**

- **مپ:**
  تابع `map` یک تابع و یک لیست را به عنوان ورودی می‌گیرد. این تابع، تابع ورودی را روی تک تک عناصر لیست اعمال کرده و لیست جدیدی با نتایج برمی‌گرداند.

**مثال:**

```python
my_list =
new_list = list(map(lambda x: x ** 2, my_list))
print(new_list)  # Output:
```

در این مثال، تابع لامبدا هر عنصر از لیست را به توان دو می‌رساند و `map` این تابع را روی تمام عناصر لیست `my_list` اعمال می‌کند. [4، 6]

- **فیلتر:**
  تابع `filter` یک تابع و یک لیست را به عنوان ورودی می‌گیرد. این تابع، عناصری از لیست را که تابع ورودی برای آنها مقدار `True` را برمی‌گرداند، نگه می‌دارد و بقیه را حذف می‌کند.

**مثال:**

```python
my_list =
new_list = list(filter(lambda x: x > 5, my_list))
print(new_list)  # Output:
```

در این مثال، تابع لامبدا بررسی می‌کند که آیا هر عنصر از لیست بزرگتر از 5 است یا خیر. [6، 7] `filter` فقط عناصری را که تابع لامبدا برای آنها `True` را برمی‌گرداند، در لیست `new_list` قرار می‌دهد. [6، 7]

- **ریدیوس:**
  تابع `reduce` یک تابع و یک لیست را به عنوان ورودی می‌گیرد. این تابع، دو عنصر از لیست را به تابع ورودی ارسال می‌کند و نتیجه را با عنصر بعدی لیست ترکیب می‌کند تا در نهایت یک نتیجه نهایی به دست آید.

**مثال:**

```python
from functools import reduce
my_list =
result = reduce(lambda x, y: x + y, my_list)
print(result)  # Output: 10
```

در این مثال، تابع لامبدا دو ورودی (x و y) را دریافت کرده و آنها را با هم جمع می‌کند. [9، 10] `reduce` از این تابع برای جمع کردن تمام عناصر لیست `my_list` استفاده می‌کند.

- **مرتب‌سازی:**
  تابع `sorted` یک لیست و یک تابع (اختیاری) را به عنوان ورودی می‌گیرد. این تابع، لیست را بر اساس خروجی تابع ورودی مرتب می‌کند.

**مثال:**

```python
my_list =
new_list = sorted(my_list, key=lambda x: x % 3)
print(new_list)  # Output:
```

در این مثال، تابع لامبدا باقی مانده تقسیم هر عنصر از لیست بر 3 را برمی‌گرداند. `sorted` از این تابع برای مرتب‌سازی لیست `my_list` استفاده می‌کند. [10، 12]

**_نکته:_** در همه این مثال‌ها، به جای تعریف جداگانه تابع و ارسال آن به توابع `map`، `filter`، `reduce` و `sorted`، از توابع لامبدا برای تعریف تابع به صورت inline استفاده شده است. [6، 8، 10، 12]

# pass

از این دستور زمانی استفاده می کنیم که نمی خواهیم بدنه یک تابع یا حلقه ای را بنویسیم و بعدا بدنه ان را می نویسیم از این دستور استفاده می کنیم

- خلاصه‌ای از ویدیو به همراه دستورات مورد نیاز

# DocString

**هدف از داک‌استرینگ توضیح عملکرد یک تابع، کلاس یا ماژول برای کاربران و برنامه‌نویسانی است که ممکن است کد را ننوشته باشند.**

**داک‌استرینگ چگونه تعریف می‌شود؟**

- برای تعریف داک‌استرینگ، کافیست در خط اول بعد از تعریف تابع، کلاس یا ماژول، یک رشته با سه علامت نقل قول ("") یا سه علامت نقل قول دوتایی (""") بنویسید.
- توصیه می‌شود از سه علامت نقل قول دوتایی استفاده شود.
- متن داک‌استرینگ می‌تواند شامل خلاصه‌ای از عملکرد، پارامترهای ورودی، خروجی‌ها و توضیحات اضافی باشد.

**مثال:**

```python
def max_3(x, y, z):
   """
  این تابع سه عدد دریافت می‌کند و بزرگترین آنها را برمی‌گرداند.

  Args:
      x (int): اولین عدد
      y (int): دومین عدد
      z (int): سومین عدد

  Returns:
      int: بزرگترین عدد از بین سه عدد ورودی
  """
  # کد تابع
  return max(x, y, z)
```

**نکات مهم:**

- داک‌استرینگ باید اولین خط بعد از تعریف تابع، کلاس یا ماژول باشد.
- استفاده از داک‌استرینگ اختیاری است، اما توصیه می‌شود برای توابع، کلاس‌ها و ماژول‌ها داک‌استرینگ بنویسید.
- داک‌استرینگ با کامنت فرق دارد. کامنت برای توضیح نحوه کار کد برای برنامه‌نویسان است، در حالی که داک‌استرینگ برای توضیح عملکرد کد برای کاربران است.

**دستورات مورد نیاز برای دسترسی به داک‌استرینگ:**

- با استفاده از اتریبیوت `__doc__` :

```python
print(max_3.__doc__)
```

- با استفاده از تابع `help()` :

```python
help(max_3)
```

اکثر توابع داخلی پایتون دارای داک‌استرینگ هستند. برای مثال:

```python
print(len.__doc__)
print(print.__doc__)
print(max.__doc__)
```

# **تکرار (Iteration)**

در پایتون، **تکرار (Iteration)** به فرآیند اجرای مکرر یک بلوک کد گفته می‌شود. این کار معمولاً با استفاده از **حلقه‌ها (Loops)** یا **توابع بازگشتی (Recursive Functions)** انجام می‌شود. در اینجا به بررسی روش‌های مختلف تکرار در پایتون می‌پردازیم.

---

## **1. حلقه `for` — تکرار بر روی عناصر یک دنباله**

حلقه `for` برای **تکرار روی عناصر یک دنباله** (مانند لیست، رشته، تاپل، دیکشنری و ...) استفاده می‌شود.

### **سینتکس پایه:**

```python
for متغیر in دنباله:
    # کدی که تکرار می‌شود
```

### **مثال‌ها:**

#### **الف) تکرار روی لیست**

```python
fruits = ["سیب", "پرتقال", "موز"]
for fruit in fruits:
    print(fruit)
```

**خروجی:**

```
سیب
پرتقال
موز
```

#### **ب) تکرار روی رشته**

```python
name = "پایتون"
for char in name:
    print(char)
```

**خروجی:**

```
پ
ا
ی
ت
و
ن
```

#### **ج) تکرار روی دیکشنری**

```python
person = {"name": "علی", "age": 25, "city": "تهران"}
for key, value in person.items():
    print(f"{key}: {value}")
```

**خروجی:**

```
name: علی
age: 25
city: تهران
```

---

## **2. حلقه `while` — تکرار تا زمانی که شرط برقرار است**

حلقه `while` تا زمانی که **شرط آن `True` باشد** اجرا می‌شود.

### **سینتکس پایه:**

```python
while شرط:
    # کدی که تکرار می‌شود
```

### **مثال‌ها:**

#### **الف) شمارش معکوس**

```python
count = 5
while count > 0:
    print(count)
    count -= 1
```

**خروجی:**

```
5
4
3
2
1
```

#### **ب) دریافت ورودی تا زمانی که کاربر "exit" وارد کند**

```python
while True:
    user_input = input("یک عبارت وارد کنید (یا exit برای خروج): ")
    if user_input.lower() == "exit":
        break
    print(f"شما وارد کردید: {user_input}")
```

---

## **3. کنترل جریان حلقه‌ها (`break`, `continue`, `else`)**

### **الف) `break` — خروج زودهنگام از حلقه**

```python
for num in range(10):
    if num == 5:
        break  # حلقه در num=5 متوقف می‌شود
    print(num)
```

**خروجی:**

```
0
1
2
3
4
```

### **ب) `continue` — رد کردن یک تکرار**

```python
for num in range(10):
    if num % 2 == 0:
        continue  # اعداد زوج را رد می‌کند
    print(num)
```

**خروجی:**

```
1
3
5
7
9
```

### **ج) `else` — اجرای کد پس از اتمام حلقه**

```python
for num in range(3):
    print(num)
else:
    print("حلقه تمام شد!")
```

**خروجی:**

```
0
1
2
حلقه تمام شد!
```

---

## **4. توابع تکرارپذیر (`range`, `enumerate`, `zip`)**

### **الف) `range()` — تولید دنباله‌ای از اعداد**

```python
for i in range(5):       # 0 تا 4
    print(i)

for i in range(2, 6):    # 2 تا 5
    print(i)

for i in range(1, 10, 2): # 1 تا 9 با گام 2
    print(i)
```

### **ب) `enumerate()` — دریافت ایندکس و مقدار**

```python
fruits = ["سیب", "پرتقال", "موز"]
for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")
```

**خروجی:**

```
0: سیب
1: پرتقال
2: موز
```

### **ج) `zip()` — ترکیب دو لیست**

```python
names = ["علی", "رضا", "مریم"]
ages = [25, 30, 28]

for name, age in zip(names, ages):
    print(f"{name}: {age} سال")
```

**خروجی:**

```
علی: 25 سال
رضا: 30 سال
مریم: 28 سال
```

---

## **5. List Comprehension — تکرار فشرده برای ساخت لیست**

```python
# ساخت لیست مربع اعداد 0 تا 9
squares = [x**2 for x in range(10)]
print(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# فیلتر کردن اعداد فرد
odd_numbers = [x for x in range(10) if x % 2 != 0]
print(odd_numbers)  # [1, 3, 5, 7, 9]
```

---

## **6. توابع بازگشتی (Recursive Functions)**

تابعی که خودش را فراخوانی می‌کند.  
**مثال: محاسبه فاکتوریل**

```python
def factorial(n):
    return 1 if n == 1 else n * factorial(n - 1)

print(factorial(5))  # 120
```

---

## **نتیجه‌گیری**

| روش تکرار          | کاربرد                           |
| ------------------ | -------------------------------- |
| `for`              | تکرار روی عناصر یک دنباله        |
| `while`            | تکرار تا زمانی که شرط برقرار است |
| `break`            | خروج زودهنگام از حلقه            |
| `continue`         | رد کردن یک تکرار                 |
| `range()`          | تولید دنباله عددی                |
| `enumerate()`      | دریافت ایندکس و مقدار            |
| `zip()`            | ترکیب دو لیست                    |
| List Comprehension | ساخت لیست به صورت فشرده          |

# Decorator

کاربرد ات جا است که یک تابع داریم و می خواهیم کار قبلی را انحام دهد ولی یک دستور به ان اضافه شود

## دکوراتور چیست؟

- دکوراتور یک تابع است که یک تابع دیگر را به عنوان ورودی می‌گیرد و یک تابع جدید را بازمی‌گرداند.
- از دکوراتورها برای اضافه کردن قابلیت‌های جدید به توابع موجود استفاده می‌شود.
- با استفاده از @decorator_name قبل از تعریف تابع اعمال می‌شوند.

## دکوراتورهای استاندارد پایتون

برخی دکوراتورهای داخلی پایتون:

| دکوراتور      | کاربرد                    |
| ------------- | ------------------------- |
| @staticmethod | تعریف متد استاتیک در کلاس |
| @classmethod  | تعریف متد کلاس            |
| @property     | تعریف ویژگی‌های کلاس      |

## کاربردهای رایج دکوراتورها

1. لاگ کردن (ثبت اطلاعات اجرا)

2. اعتبارسنجی (مثلاً چک کردن ورودی‌ها)

3. کش کردن (ذخیره نتایج برای عملکرد بهتر)

4. تعیین سطح دسترسی (مثلاً چک کردن لاگین کاربر)

5. تایمر (اندازه‌گیری زمان اجرا)

## فرم کلی

```py
import functools

def Decorator(func):
@functools.warps(func)
def warpper_decorator(*Args, **kwargs):
    #do somthing before
    value = func(*Args, **kwargs):
    # do somthing after
    return value
return warpper_decorator
```

## مثال :

```py

def dec(func):
    def inner(x, y):
        if y == 0:
            return "warning!!!"
        return func(x, y)
    return inner

@dec
def f(x, y)
    return x/y

print(f(10, 12))
#برای انکه بتوانیم از تابع بالا هر جا که خواستیم استفاده کنیم باید در تعریف متغیر (قبل ) از * استافده کنیم
```

```py
def dec(func):
    def inner(*x, **y):
        if y == 0:
            return "warning!!!"
        return func(x, y)
    return inner

@dec
def f(x, y, z)
    return x/y+2

print(f(10, 12, 0))
```

## نکات مهم

- دکوراتورها می‌توانند تابع یا کلاس را تغییر دهند.

- ترتیب اعمال دکوراتورها مهم است (@A @B def f() معادل A(B(f)) است).

- برای حفظ متادیتاهای تابع اصلی (مثل **name**) از functools.wraps استفاده کنید.

مثال با functools.wraps:

```py
from functools import wraps

def debug(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"فراخوانی {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@debug
def say_hello():
    """این تابع سلام می‌کند"""
    print("سلام!")

print(say_hello.__name__)  # خروجی: say_hello (بدون wraps میشد wrapper)
print(say_hello.__doc__)   # خروجی: این تابع سلام می‌کند
```

## جمع‌بندی

| مفهوم               | مثال              | کاربرد                   |
| ------------------- | ----------------- | ------------------------ |
| دکوراتور ساده       | @decorator        | اضافه کردن قابلیت جدید   |
| دکوراتور با پارامتر | @decorator(arg)   | پیکربندی دکوراتور        |
| چند دکوراتور        | @A @B def f()     | ترکیب قابلیت‌ها          |
| @property           | @property def x() | کنترل دسترسی به ویژگی‌ها |

# ژنراتورها (Generators)

## 1. ژنراتور

- **تابع ویژه‌ای** که به جای `return` از `yield` استفاده می‌کند.
- **مقادیر را به صورت تنبل (Lazy Evaluation)** تولید می‌کند (یعنی فقط وقتی درخواست شود).
- **حافظه را بهینه می‌کند** (برای داده‌های حجیم ایده‌آل است).

---

## 2. ساخت ژنراتور

### تابع ژنراتور (با `yield`)

```python
def count_up_to(n):
    num = 1
    while num <= n:
        yield num  # مقدار را برمی‌گرداند و مکث می‌کند
        num += 1

# استفاده:
counter = count_up_to(5)
print(next(counter))  # 1
print(next(counter))  # 2
```

---

## 3. تفاوت ژنراتور با لیست معمولی

| ویژگی      | لیست                        | ژنراتور                  |
| ---------- | --------------------------- | ------------------------ |
| **حافظه**  | تمام مقادیر را ذخیره می‌کند | فقط یک مقدار در هر زمان  |
| **سرعت**   | سریع برای دسترسی تصادفی     | سریع برای پردازش ترتیبی  |
| **کاربرد** | داده‌های کوچک               | داده‌های حجیم یا بینهایت |

**مثال: تولید اعداد بینهایت**

```python
def infinite_numbers():
    num = 0
    while True:
        yield num
        num += 1

gen = infinite_numbers()
print(next(gen))  # 0
print(next(gen))  # 1
# ادامه دارد...
```

---

## 4. مثال

### الف) پردازش فایل‌های حجیم

```python
def read_large_file(file_path):
    with open(file_path, 'r') as file:
        for line in file:
            yield line.strip()

# استفاده بدون مصرف حافظه زیاد:
for line in read_large_file('data.txt'):
    print(line)
```

### ب) تولید دنباله‌های ریاضی

```python
def fibonacci(limit):
    a, b = 0, 1
    while a < limit:
        yield a
        a, b = b, a + b

print(list(fibonacci(50)))  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

### ج) خط لوله پردازش داده (Pipeline)

```python
def numbers():
    yield from range(10)

def squared(nums):
    for n in nums:
        yield n**2

def even(nums):
    for n in nums:
        if n % 2 == 0:
            yield n

# ترکیب ژنراتورها:
result = even(squared(numbers()))
print(list(result)))  # [0, 4, 16, 36, 64]
```

### ه) ژنراتور برای فیلتر کردن داده‌ها

```python
def filter_data(data, condition):
    for item in data:
        if condition(item):
            yield item

data = [10, 4, 7, 18, 2]
filtered = filter_data(data, lambda x: x > 5)
print(list(filtered)))  # [10, 7, 18]
```

### مثال های بیشتر

```py
def func(x):
    print("reza")
    yield x**2
    print("hello")
    yield 5
    print("ok")
    yield x-2

x = func(5)
next(x)
next(x)
next(x)

#output
#    reza
#    hello
#    ok
```

```py
def func(x):
    print("reza")
    yield x**2
    print("hello")
    yield 5
    print("ok")
    yield x-2

x = func(5)
    print(next(x))
    print(next(x))

#output
#    reza
#    25

#    hello
#    5
```

```py
def func():
    for i in range(1000):
        yield i**2

g = func()
print(next(g))
print(next(g))
.
.
.

```

```py
#جلوگیری از خطای استاب ایتریشن
def my_generator():
    print("welcome!")
    for i in range(5):
    yield i **2

g = my_generator()
iter_ = iter([1, 2, 3])

for i in g:
    print(i)
```

---

## 5. تفاوت `yield` و `return`

| ویژگی         | `yield`                         | `return`                |
| ------------- | ------------------------------- | ----------------------- |
| **حالت تابع** | تابع به حالت تعلیق درمی‌آید     | تابع خاتمه می‌یابد      |
| **مقادیر**    | چندین مقدار تولید می‌کند        | یک مقدار برمی‌گرداند    |
| **حافظه**     | مقادیر را یک به یک تولید می‌کند | همه را یکجا برمی‌گرداند |

---

## خلاصه

- **ژنراتور = تابع + `yield`**
- **بهینه برای داده‌های حجیم**
- **ترکیب‌پذیر با `for` و سایر ژنراتورها**
- **مصرف با `next()` یا حلقه‌ها**

# متت های لیست
در پایتون، لیست (List) یکی از ساختارهای داده‌ای پرکاربرد است که متدهای (methods) مختلفی برای مدیریت و دستکاری عناصر آن وجود دارد. در زیر مهم‌ترین متدهای لیست در پایتون را بررسی می‌کنیم:

### **۱. متدهای اضافه کردن عناصر**
- **`append(x)`**  
  یک عنصر `x` را به **انتهای** لیست اضافه می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.append(4)
  print(lst)  # خروجی: [1, 2, 3, 4]
  ```

- **`extend(iterable)`**  
  عناصر یک لیست یا شیء قابل پیمایش (iterable) را به انتهای لیست اضافه می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.extend([4, 5])
  print(lst)  # خروجی: [1, 2, 3, 4, 5]
  ```

- **`insert(i, x)`**  
  عنصر `x` را در **موقعیت `i`** درج می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.insert(1, 99)
  print(lst)  # خروجی: [1, 99, 2, 3]
  ```

### **۲. متدهای حذف عناصر**
- **`remove(x)`**  
  اولین عنصر با مقدار `x` را حذف می‌کند. اگر عنصر وجود نداشته باشد، `ValueError` می‌دهد.  
  مثال:
  ```python
  lst = [1, 2, 3, 2]
  lst.remove(2)
  print(lst)  # خروجی: [1, 3, 2]
  ```

- **`pop([i])`**  
  عنصر در **موقعیت `i`** را حذف و برمی‌گرداند. اگر `i` مشخص نشود، آخرین عنصر حذف می‌شود.  
  مثال:
  ```python
  lst = [1, 2, 3, 4]
  x = lst.pop(1)
  print(x)    # خروجی: 2
  print(lst)  # خروجی: [1, 3, 4]
  ```

- **`clear()`**  
  تمام عناصر لیست را حذف می‌کند و لیست خالی می‌شود.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.clear()
  print(lst)  # خروجی: []
  ```

### **۳. متدهای جستجو و اطلاعات**
- **`index(x[, start[, end]])`**  
  اولین ایندکس عنصر `x` را برمی‌گرداند. اگر وجود نداشته باشد، `ValueError` می‌دهد.  
  مثال:
  ```python
  lst = [10, 20, 30, 20]
  print(lst.index(20))       # خروجی: 1
  print(lst.index(20, 2))    # خروجی: 3 (جستجو از ایندکس 2)
  ```

- **`count(x)`**  
  تعداد تکرارهای عنصر `x` در لیست را برمی‌گرداند.  
  مثال:
  ```python
  lst = [1, 2, 2, 3, 2]
  print(lst.count(2))  # خروجی: 3
  ```

### **۴. متدهای مرتب‌سازی و تغییر ترتیب**
- **`sort(key=None, reverse=False)`**  
  لیست را **به‌صورت درجا** (in-place) مرتب می‌کند.  
  مثال:
  ```python
  lst = [3, 1, 4, 2]
  lst.sort()
  print(lst)  # خروجی: [1, 2, 3, 4]
  ```

- **`reverse()`**  
  ترتیب عناصر لیست را معکوس می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.reverse()
  print(lst)  # خروجی: [3, 2, 1]
  ```

  ### تفاوت `reverse()` و `reversed()`:
  - **`list.reverse()`**:  
    - یک **متد لیست** است و لیست را **درجا (in-place)** معکوس می‌کند (یعنی لیست اصلی تغییر می‌کند).  
    - مقدار بازگشتی ندارد (`None` برمی‌گرداند).  
    مثال:
    ```python
    lst = [1, 2, 3]
    lst.reverse()
    print(lst)  # خروجی: [3, 2, 1] (لیست اصلی تغییر کرد)
    ```

  - **`reversed(list)`**:  
    - یک **تابع built-in** است و لیست اصلی را تغییر **نمی‌دهد**.  
    - یک **iterator** برمی‌گرداند که عناصر را به صورت معکوس می‌دهد.  
    - برای تبدیل به لیست، باید از `list()` استفاده کرد.  
    مثال:
    ```python
    lst = [1, 2, 3]
    reversed_lst = reversed(lst)  # یک iterator برمی‌گرداند
    print(list(reversed_lst))     # خروجی: [3, 2, 1]
    print(lst)                   # خروجی: [1, 2, 3] (لیست اصلی تغییر نکرده)
    ```

  ### کاربرد `reversed()`:
  - وقتی می‌خواهید لیست را معکوس کنید **بدون تغییر لیست اصلی**.  
  - مناسب برای حلقه‌های معکوس:
    ```python
    for item in reversed([1, 2, 3]):
        print(item)  # چاپ: 3, 2, 1
    ```

  ### مثال‌های بیشتر:
  ```python
  # معکوس کردن یک رشته
  s = "hello"
  print(list(reversed(s)))  # ['o', 'l', 'l', 'e', 'h']
  print(''.join(reversed(s)))  # 'olleh'

  # معکوس کردن تاپل
  t = (1, 2, 3)
  print(tuple(reversed(t)))  # (3, 2, 1)
  ```

### **۵. متدهای کپی و ایجاد لیست جدید**
- **`copy()`**  
  یک **کپی سطحی** (shallow copy) از لیست ایجاد می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst2 = lst.copy()
  print(lst2)  # خروجی: [1, 2, 3]
  ```

### **۶. سایر متدهای مفید**
- **`len(list)`** (تابع built-in)  
  تعداد عناصر لیست را برمی‌گرداند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  print(len(lst))  # خروجی: 3
  ```

- **`max(list)` و `min(list)`** (توابع built-in)  
  بزرگترین و کوچکترین عنصر لیست را برمی‌گردانند.  
  مثال:
  ```python
  lst = [5, 2, 8, 1]
  print(max(lst))  # خروجی: 8
  print(min(lst))  # خروجی: 1
  ```

### **جمع‌بندی**
| متد | توضیح |
|------|------|
| `append(x)` | اضافه کردن `x` به انتهای لیست |
| `extend(iterable)` | اضافه کردن چند عنصر به لیست |
| `insert(i, x)` | درج `x` در موقعیت `i` |
| `remove(x)` | حذف اولین عنصر با مقدار `x` |
| `pop([i])` | حذف و برگرداندن عنصر در موقعیت `i` |
| `clear()` | خالی کردن لیست |
| `index(x)` | یافتن ایندکس اولین وقوع `x` |
| `count(x)` | شمارش تعداد تکرار `x` |
| `sort()` | مرتب‌سازی لیست |
| `reverse()` | معکوس کردن ترتیب لیست |
| `copy()` | ایجاد کپی از لیست |

# متد های تاپل و مجموعه ها
---

##  **متدهای تاپل (Tuple Methods)**  
تاپل‌ها **Immutable** هستند، بنابراین متدهای تغییردهنده (مانند `append()` یا `remove()`) را ندارند.

### ۱- **`count(x)`**  
تعداد تکرارهای عنصر `x` در تاپل را برمی‌گرداند.  
```python
t = (1, 2, 2, 3, 2)
print(t.count(2))  # خروجی: 3
```

### ۲- **`index(x)`**  
اولین ایندکس عنصر `x` را برمی‌گرداند. اگر وجود نداشته باشد، `ValueError` می‌دهد.  
```python
t = (10, 20, 30, 20)
print(t.index(20))  # خروجی: 1
```

###  **نکته مهم:**  
- تاپل‌ها متدهای `append()`، `remove()`، `sort()` و ... **ندارند** چون غیرقابل تغییر هستند.  
- اگر نیاز به تغییر دارید، باید تاپل را به لیست تبدیل کنید و دوباره تاپل بسازید:
  ```python
  t = (1, 2, 3)
  lst = list(t)
  lst.append(4)
  t = tuple(lst)
  print(t)  # خروجی: (1, 2, 3, 4)
  ```

---

##  **متدهای مجموعه (Set Methods)**  
مجموعه‌ها (**Set**) **ترتیب ندارند** و **عناصر تکراری** را ذخیره نمی‌کنند. متدهای اصلی آنها:

### ۱- **اضافه و حذف عناصر**  
| متد | توضیح |
|------|-------|
| `add(x)` | اضافه کردن `x` به مجموعه |
| `remove(x)` | حذف `x` از مجموعه (اگر نباشد `KeyError` می‌دهد) |
| `discard(x)` | حذف `x` از مجموعه (اگر نباشد خطا نمی‌دهد) |
| `pop()` | یک عنصر **تصادفی** حذف و برمی‌گرداند |
| `clear()` | پاک کردن تمام مجموعه |

مثال:
```python
s = {1, 2, 3}
s.add(4)       # {1, 2, 3, 4}
s.remove(2)    # {1, 3, 4}
s.discard(99)  # خطا نمی‌دهد
print(s.pop()) # یک عنصر تصادفی برمی‌گرداند
```

### ۲- **عملیات مجموعه‌ها**  
| متد | توضیح |
|------|-------|
| `union(other_set)` | اجتماع دو مجموعه (`|`) |
| `intersection(other_set)` | اشتراک دو مجموعه (`&`) |
| `difference(other_set)` | تفاوت دو مجموعه (`-`) |
| `symmetric_difference(other_set)` | تفاضل متقارن (`^`) |
| `update(other_set)` | اضافه کردن همه عناصر `other_set` به مجموعه فعلی |

مثال:
```python
A = {1, 2, 3}
B = {3, 4, 5}
print(A.union(B))            # {1, 2, 3, 4, 5}
print(A.intersection(B))     # {3}
print(A.difference(B))       # {1, 2}
print(A.symmetric_difference(B))  # {1, 2, 4, 5}
```

### ۳- **متدهای بررسی**  
| متد | توضیح |
|------|-------|
| `issubset(other_set)` | آیا مجموعه زیرمجموعه `other_set` است؟ |
| `issuperset(other_set)` | آیا مجموعه ابرمجموعه `other_set` است؟ |
| `isdisjoint(other_set)` | آیا دو مجموعه اشتراکی ندارند؟ |

مثال:
```python
A = {1, 2}
B = {1, 2, 3}
print(A.issubset(B))    # True
print(B.issuperset(A))  # True
print(A.isdisjoint({4, 5}))  # True
```


#### **4- متد `difference()`**  
تفاوت دو مجموعه را برمی‌گرداند (عناصری که در مجموعه اول هستند ولی در مجموعه دوم نیستند).  
✅ **تغییری در مجموعه اصلی ایجاد نمی‌کند.**  
```python
s = {1, 2, 3, 4}
x = {3, 4, 5, 6}
print(s.difference(x))  # خروجی: {1, 2}
print(s)  # خروجی: {1, 2, 3, 4} (مجموعه اصلی تغییر نکرده)
```

#### **5- متد `difference_update()`**  
تفاوت دو مجموعه را محاسبه کرده و **تغییرات را روی مجموعه اصلی اعمال می‌کند.**  
❌ **مجموعه اصلی را تغییر می‌دهد و مقدار بازگشتی ندارد (`None`).**  
```python
s = {1, 2, 3, 4}
x = {3, 4, 5, 6}
s.difference_update(x)  # اعمال تغییرات روی s
print(s)  # خروجی: {1, 2} (مجموعه اصلی تغییر کرد)
```

#### **6- متد `isdisjoint()`**  
اگر دو مجموعه **هیچ عنصر مشترکی نداشته باشند**، `True` برمی‌گرداند.  
```python
s = {1, 2, 3, 4}
x = {5, 6, 7}
print(s.isdisjoint(x))  # خروجی: True (چون اشتراکی ندارند)

y = {3, 4, 5}
print(s.isdisjoint(y))  # خروجی: False (چون ۳ و ۴ مشترک هستند)
```

---

### **جمع‌بندی متدهای مجموعه (Set)**
| متد | توضیح | تغییر در مجموعه اصلی؟ |
|------|-------|------------------|
| `difference()` | تفاوت دو مجموعه را برمی‌گرداند | ❌ |
| `difference_update()` | تفاوت را روی مجموعه اصلی اعمال می‌کند | ✅ |
| `isdisjoint()` | بررسی عدم اشتراک دو مجموعه | ❌ |


---


### **جمع‌بندی:**
| نوع | مهم‌ترین متدها |
|------|---------------|
| **تاپل** | `count()`, `index()` |
| **مجموعه** | `add()`, `remove()`, `union()`, `intersection()`, `difference()` |


---
# متد های دیکشنری

## **متدهای اصلی دیکشنری**

### 1. **`keys()`**  
تمام کلیدهای دیکشنری را به صورت یک شیء `dict_keys` برمی‌گرداند.  
```python
d = {'a': 1, 'b': 2, 'c': 3}
print(d.keys())  # خروجی: dict_keys(['a', 'b', 'c'])
```

### 2. **`values()`**  
تمام مقادیر دیکشنری را به صورت یک شیء `dict_values` برمی‌گرداند.  
```python
print(d.values())  # خروجی: dict_values([1, 2, 3])
```

### 3. **`items()`**  
تمام زوج‌های `(key, value)` را به صورت یک شیء `dict_items` برمی‌گرداند.  
```python
print(d.items())  # خروجی: dict_items([('a', 1), ('b', 2), ('c', 3)])
```

### 4. **`get(key[, default])`**  
مقدار متناظر با `key` را برمی‌گرداند. اگر کلید وجود نداشته باشد، `default` (پیش‌فرض: `None`) برگردانده می‌شود.  
- (کلید را مشخص می کنیم ومقدار ان را برمی‌گرداند)
```python
print(d.get('a'))     # خروجی: 1
print(d.get('x', 0))  # خروجی: 0 (چون 'x' وجود ندارد)
```
```py
d = {"a":1, "b":2}
  print(d.get("c",میتوان در صورت نان بودن یک چیزی برمی گرداند))
```
### 5. **`setdefault(key[, default])`**  
- اگر `key` وجود داشته باشد، مقدار آن را برمی‌گرداند.  
- اگر وجود نداشته باشد، کلید را با مقدار `default` (پیش‌فرض: `None`) اضافه می‌کند.  
```python
d.setdefault('b', 0)  # 'b' وجود دارد، پس مقدار 2 برمی‌گردد
d.setdefault('x', 10) # 'x' اضافه می‌شود: {'a':1, 'b':2, 'c':3, 'x':10}
```
```py
d = {"a":1, "b":2}
  print(d.setdefault("d",0))
```

### 6. **`update([other])`**  
دیکشنری را با زوج‌های `(key, value)` از `other` (دیکشنری یا شیء قابل پیمایش) به‌روز می‌کند.  
- یک دیکشنری جدید می گیرد و به دیکشنری قبیل اضافه می کند
```python
d.update({'b': 20, 'd': 4})  # d میشود: {'a':1, 'b':20, 'c':3, 'x':10, 'd':4}
```
```py
d = {"a":1, "b":2}
d.update{"z":0, "k":5, "l":7}

#2
d = {"a":1, "b":2}
d.update{"a":0, "k":5, "l":7}
```
### 7. **`pop(key[, default])`**  
کلید `key` را حذف و مقدار آن را برمی‌گرداند. اگر کلید وجود نداشته باشد و `default` مشخص نشده باشد، `KeyError` می‌دهد.  
```python
val = d.pop('b')  # val = 20, d حذف میشود: {'a':1, 'c':3, 'x':10, 'd':4}
# example-2
d = {"a":1, "b":2}
  print(d.pop("a"))
```

### 8. **`popitem()`**  
یک زوج `(key, value)` را به صورت **تصادفی** (در نسخه‌های جدید، آخرین عنصر) حذف و برمی‌گرداند. اگر دیکشنری خالی باشد، `KeyError` می‌دهد.  
```python
item = d.popitem()  # مثلاً: ('d', 4)
```

### 9. **`clear()`**  
تمام عناصر دیکشنری را پاک می‌کند.  
```python
d.clear()  # d میشود: {}
```

### 10. **`copy()`**  
یک کپی سطحی (Shallow Copy) از دیکشنری ایجاد می‌کند.  
```python
d = {'a': 1, 'b': [2, 3]}
d_copy = d.copy()
```

### 11. **`fromkeys(iterable[, value])`** (متد کلاس)  
یک دیکشنری جدید با کلیدهای از `iterable` و مقادیر یکسان `value` (پیش‌فرض: `None`) می‌سازد.  
```python
keys = ['a', 'b', 'c']
new_dict = dict.fromkeys(keys, 0)  # {'a': 0, 'b': 0, 'c': 0}
```

---

##  **متدهای بررسی و کاربردهای پیشرفته**

### 12. **`len(dict)`**  
تعداد کلیدهای دیکشنری را برمی‌گرداند.  
```python
print(len({'a': 1, 'b': 2}))  # خروجی: 2
```

### 13. **`in` Operator**  
بررسی وجود یک کلید در دیکشنری.  
```python
d = {'a': 1}
print('a' in d)  # True
```

### 14. **حلقه بر روی دیکشنری**  
- کلیدها:  
  ```python
  for key in d:
      print(key, d[key])
  ```
- مقادیر:  
  ```python
  for value in d.values():
      print(value)
  ```
- کلید و مقدار:  
  ```python
  for key, value in d.items():
      print(key, value)
  ```

---

##  **تفاوت `copy()` و `deepcopy()`**
- **`copy()`**: کپی سطحی (تغییر در لیست‌های تو در تو تأثیرگذار است).  
- **`deepcopy()` (از ماژول `copy`)**: کپی عمیق (تمامی سطوح کپی می‌شوند).  
```python
import copy
d = {'a': [1, 2]}
d_shallow = d.copy()
d_deep = copy.deepcopy(d)
```

---

## 📊 **جمع‌بندی متدهای دیکشنری**
| متد | توضیح | مثال |
|------|--------|------|
| `keys()` | لیست کلیدها | `dict.keys()` |
| `values()` | لیست مقادیر | `dict.values()` |
| `items()` | لیست زوج‌های کلید-مقدار | `dict.items()` |
| `get()` | دریافت مقدار با کلید | `dict.get('a', 0)` |
| `setdefault()` | اضافه کردن کلید با مقدار پیش‌فرض | `dict.setdefault('x', 10)` |
| `update()` | به‌روزرسانی دیکشنری | `dict.update({'b': 20})` |
| `pop()` | حذف کلید و برگشت مقدار | `dict.pop('a')` |
| `popitem()` | حذف و برگشت آخرین عنصر | `dict.popitem()` |
| `clear()` | پاک کردن دیکشنری | `dict.clear()` |
| `copy()` | کپی سطحی | `dict.copy()` |
| `fromkeys()` | ساخت دیکشنری جدید | `dict.fromkeys(['a', 'b'], 0)` |

# متد رشته
---


## **1. تبدیل حروف و نرمال‌سازی**  
این متدها برای تغییر حالت حروف (بزرگ/کوچک) و یکسان‌سازی متن استفاده می‌شوند.  

| متد | توضیح | مثال | تفاوت‌های کلیدی |
|------|--------|------|----------------|
| **`upper()`** | تبدیل به حروف بزرگ | `"hello".upper() → "HELLO"` | - |
| **`lower()`** | تبدیل به حروف کوچک | `"HELLO".lower() → "hello"` | فقط برای انگلیسی بهینه است. |
| **`casefold()`** | مثل `lower()` اما برای زبان‌های غیرانگلیسی | `"HELLO ß".casefold() → "hello ss"` | `ß` در آلمانی به `ss` تبدیل می‌شود. |
| **`capitalize()`** | اولین حرف بزرگ، بقیه کوچک | `"hello".capitalize() → "Hello"` | - |
| **`title()`** | اولین حرف هر کلمه بزرگ | `"hello world".title() → "Hello World"` | - |
| **`swapcase()`** | معکوس کردن حروف بزرگ/کوچک | `"Hello".swapcase() → "hELLO"` | - |

---

## **2. جستجو و بررسی محتوا**  
برای پیدا کردن زیررشته‌ها و اعتبارسنجی محتوا.  

| متد | توضیح | مثال | تفاوت‌های کلیدی |
|------|--------|------|----------------|
| **`find(sub)`** | ایندکس اولین وقوع زیررشته | `"hello".find("e") → 1` | اگر نباشد `-1` برمی‌گرداند. |
| **`index(sub)`** | مثل `find()` اما با `ValueError` | `"hello".index("e") → 1` | اگر نباشد خطا می‌دهد. |
| **`count(sub)`** | شمارش تکرار زیررشته | `"hello".count("l") → 2` | - |
| **`startswith(prefix)`** | آیا رشته با پیشوند شروع می‌شود؟ | `"hello".startswith("he") → True` | - |
| **`endswith(suffix)`** | آیا رشته با پسوند پایان می‌یابد؟ | `"hello".endswith("lo") → True` | - |
| **`isalpha()`** | آیا همه کاراکترها حروف الفبا هستند؟ | `"abc".isalpha() → True` | - |
| **`isascii()`** | آیا همه کاراکترها در محدوده ASCII هستند؟ | `"hello".isascii() → True` | - |
| **`isdigit()`** | آیا همه کاراکترها رقم هستند؟ | `"123".isdigit() → True` | فقط اعداد عربی (`0-9`). |
| **`isdecimal()`** | مثل `isdigit()` اما برای اعداد عربی/فارسی | `"۱۲۳".isdecimal() → True` | - |
| **`isnumeric()`** | گسترده‌تر از `isdigit()` (شامل رقم‌های چینی، رومی و ...) | `"四".isnumeric() → True` | - |

---

## 3. **اصلاح و فرمت‌دهی متن**
برای تغییر ظاهر رشته و ساخت متن‌های پویا.  

| متد | توضیح | مثال | تفاوت‌های کلیدی |
|------|--------|------|----------------|
| **`strip()`** | حذف فاصله از دو طرف | `"  hello  ".strip() → "hello"` | - |
| **`split(sep)`** | تقسیم رشته به لیست | `"a,b,c".split(",") → ["a","b","c"]` | - |
| **`join(list)`** | اتصال لیست به رشته | `"-".join(["a","b"]) → "a-b"` | - |
| **`replace(old, new)`** | جایگزینی زیررشته | `"hello".replace("e","a") → "hallo"` | - |
| **`center(width, fill)`** | چینش متن در وسط با کاراکتر پرکننده | `"hi".center(6, "+") → "++hi++"` | - |
| **`expandtabs(n)`** | جایگزینی تب (`\t`) با `n` فاصله | `"a\tb".expandtabs(4) → "a    b"` | - |
| **`format()`** | جایگزینی مقادیر در متن | `"{}".format(1) → "1"` | - |
| **`format_map(dict)`** | جایگزینی با دیکشنری | `"{name}".format_map({"name":"Ali"}) → "Ali"` | - |

---

## **🔹 نکات کلیدی و تفاوت‌های مهم**  

### **✅ `casefold()` vs `lower()`**  
- `casefold()` برای **زبان‌های غیرانگلیسی** (مثل آلمانی) بهتر است.  
- `lower()` فقط حروف انگلیسی را پشتیبانی می‌کند.  

### **✅ `isdigit()` vs `isdecimal()` vs `isnumeric()`**  
| متد | پشتیبانی از اعداد فارسی/عربی | پشتیبانی از اعداد دیگر زبان‌ها |
|------|----------------|----------------|
| `isdigit()` | ❌ خیر | ❌ خیر |
| `isdecimal()` | ✅ بله | ❌ خیر |
| `isnumeric()` | ✅ بله | ✅ بله (مثل چینی "四") |

---

## **📊 جمع‌بندی نهایی**  
- **برای تغییر حروف:** `upper()`, `lower()`, `casefold()`  
- **برای جستجو:** `find()`, `index()`, `count()`  
- **برای بررسی محتوا:** `isalpha()`, `isdigit()`, `isnumeric()`  
- **برای فرمت‌دهی:** `format()`, `format_map()`, `center()`  


---
# عملگر والروس
با عملگر والروس می توان همزمان مقدار دهی کرد و استفده کرد
## **کاربرد اصلی**  
- **مشکل قدیمی:**  
  در گذشته، برای اختصاص یک مقدار و استفاده از آن در یک شرط، مجبور بودیم دو خط کد بنویسیم:  
  ```python
  number = input("عدد وارد کنید: ")
  if int(number) > 10:
      print("بزرگتر از ۱۰")
  ```  

- **راه حل با والروس:**  
  با `:=` می‌توان هر دو کار را **در یک خط** انجام داد:  
  ```python
  if (number := int(input("عدد وارد کنید: "))) > 10:
      print("بزرگتر از ۱۰")
  ```  
  - مقدار `input` مستقیماً به `number` اختصاص می‌یابد و در شرط استفاده می‌شود.  

---

## مثال‌های کاربردی

### ۱. **حلقه‌های `while` با خواندن مقادیر**  
```python
while (line := input("متن را وارد کنید (خروج: enter): ")) != "":
    print(f"شما نوشتید: {line}")
```

### ۲. **محاسبات سنگین را یک بار انجام دهید و نتیجه را ذخیره کنید**  
```python
if (result := some_expensive_calculation()) > 100:
    print(f"نتیجه بزرگ است: {result}")
```

### ۳. **فیلتر کردن لیست‌ها با اختصاص ضمنی**  
```python
numbers = [12, 34, 1, 5, 90]
filtered = [n for n in numbers if (sqrt := n ** 0.5) > 5]
print(filtered)  # اعدادی که جذر آنها بزرگتر از ۵ است
```

---

## محدودیت‌ها و نکات مهم
- **پایتون ۳.۸+:** این عملگر فقط در نسخه‌های جدید پایتون کار می‌کند.  
- **خوانایی کد:** اگر استفاده از آن باعث گیجی شود، بهتر است از روش سنتی (دو خطی) استفاده کنید.  
- **پرانتز ضروری است:** برای جلوگیری از ابهام، باید حول عبارت والروس پرانتز بگذارید:  
  ```python
  # ✅ صحیح
  if (x := 10) > 5:
      print(x)

  # ❌ غلط (خطای نحوی)
  if x := 10 > 5:
      print(x)
  ```

---

### **🔹 چه زمانی از والروس استفاده کنیم؟**  
- وقتی می‌خواهید **کد را فشرده‌تر** کنید.  
- وقتی **مقدار محاسبه‌شده** را **بعداً** در کد نیاز دارید.  
- در **شرط‌ها** یا **حلقه‌های** پیچیده.  

### **🔹 چه زمانی استفاده نکنیم؟**  
- اگر باعث **کاهش خوانایی** کد شود.  
- اگر نیاز به **پشتیبانی از پایتون قدیمی** دارید.  

--- 

# تابع open( )

تابع `open()` : این تابع امکان خواندن، نوشتن و مدیریت فایل‌ها را فراهم می‌کند.
1. پارامتر های 2 و 3 و 4 و 5 و 6 و 8 ***اختیاری*** است
2. پارامتر 7 اختیاری است و به صورت پش فرض **True**
3. پارامتر 1 **الزامی** است
## ساختار کلی تابع

```python
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
```

## پارامترهای تابع open( )

### 1. پارامتر `file` 
- مسیر فایل را مشخص می‌کند
- می‌تواند به صورت نسبی یا مطلق باشد
- مثال:
  ```python
  # مسیر نسبی
  file = open('data.txt')
  
  # مسیر مطلق
  file = open('/path/to/your/file.txt')
  ```

### 2. پارامتر `mode` 
پارامتر `mode` ***اختیاری*** است و به صورت پیشفرض از حالت پایه ی `r` استفاده می کند.
- این آرگومان مشخص می‌کند که فایل با چه حالتی باز شود.  
**حالت‌های اصلی:**

#### حالت‌های پایه:
- `'r'`: فقط خواندن (پیش‌فرض)
- `'w'`: فقط نوشتن (محتوای قبلی پاک می‌شود)
- `'a'`: فقط نوشتن در انتهای فایل (الحاق)
- `'x'`: ایجاد انحصاری (خطا می‌دهد اگر فایل وجود داشته باشد)

#### حالت‌های ترکیبی:
- `'r+'`: خواندن و نوشتن
- `'w+'`: خواندن و نوشتن (محتوای قبلی پاک می‌شود)
- `'a+'`: خواندن و نوشتن در انتهای فایل

#### حالت‌های باینری:
- `'b'`: حالت باینری (برای فایل‌های غیرمتنی)
- `'t'`: حالت متنی (پیش‌فرض)

ترکیب حالت‌ها:
```py
'rb'  # خواندن باینری
'wb'  # نوشتن باینری
'rt'  # خواندن متنی (معادل 'r')
'wt'  # نوشتن متنی (معادل 'w')
```

### 3. پارامتر `buffering`
سیاست بافرینگ را تعیین می‌کند:
- `0`: غیرفعال کردن بافرینگ (فقط در حالت باینری)
- `1`: بافرینگ خطی (در حالت متنی)
- عدد صحیح بزرگتر از ۱: اندازه بافر به بایت
- عدد منفی: استفاده از مقدار پیش‌فرض سیستم

#### **Buffering و انواع ان**
-Buffering در پایتون به معنای استفاده از یک حافظه موقت (بافر) برای ذخیره‌سازی داده‌ها قبل از نوشتن روی دیسک یا خواندن از دیسک است. این مکانیسم برای بهبود کارایی و کاهش تعداد دسترسی‌های مستقیم به دیسک (که کند است) استفاده می‌شود.

##### **انواع Buffering :**
1. بدون بافرینگ `(buffering=0):`
داده‌ها بلافاصله و بدون استفاده از بافر نوشته یا خوانده می‌شوند.
فقط در حالت باینری `('b')` قابل استفاده است.

2. بافرینگ خطی `(buffering=1):`
در حالت متنی `('t')`، داده‌ها به صورت خط به خط بافر می‌شوند.
در حالت باینری، معادل buffering با اندازه ۱ بایت است.

3. بافرینگ با اندازه مشخص `(buffering > 1):`
داده‌ها در بلوک‌هایی با اندازه مشخص بافر می‌شوند.
برای بهبود عملکرد در عملیات‌های خواندن و نوشتن زیاد مفید است.

### 4. پارامتر `encoding` 
- این آرگومان مشخص می‌کند که از چه *encoding (رمزگذاری)* برای فایل متنی استفاده شود. پیش‌فرض آن بستگی به سیستم عامل دارد (معمولاً `'utf-8'`).

کدگذاری متن فایل را مشخص می‌کند:

- مثال:
  ```python
  file = open('data.txt', encoding='utf-8')
  ```

### 5. پارامتر `errors`
- این آرگومان مشخص می‌کند که چگونه خطاهای **encoding/decoding** مدیریت شوند. 
رفتار در مواجهه با خطاهای کدگذاری:
- `'strict'`: ایجاد خطا (پیش‌فرض)
- `'ignore'`: نادیده گرفتن خطاها
- `'replace'`: جایگزینی با علامت ؟
- `'backslashreplace'`: جایگزینی با توالی پشت‌شیوه

### 6. پارامتر `newline` 
مدیریت کاراکترهای خط جدید:
- `None`: تبدیل خودکار خطوط جدید
- `''`: عدم تبدیل خطوط جدید
- `'\n'`, `'\r'`, `'\r\n'`: استفاده از کاراکتر مشخص شده

### 7. پارامتر `closefd` 
- اگر `False` باشد، descriptor فایل پس از بسته شدن باز می‌ماند

### 8. پارامتر `opener` 
- این آرگومان یک تابع سفارشی برای باز کردن فایل ارائه می‌دهد. تابع باید یک file descriptor بازگرداند.

تابع سفارشی برای باز کردن فایل:
```python
def custom_opener(file, flags):
    return os.open(file, flags, 0o644)

file = open('data.txt', opener=custom_opener)
```

## روش‌های کار با فایل باز شده

### متدهای اصلی:
1. `read(size=-1)`: خواندن محتوا
2. `readline(size=-1)`: خواندن یک خط
3. `readlines(hint=-1)`: خواندن تمام خطوط
4. `write(s)`: نوشتن رشته
5. `writelines(lines)`: نوشتن چندین خط
6. `seek(offset, whence=0)`: تغییر موقعیت
7. `tell()`: گزارش موقعیت فعلی
8. `flush()`: تخلیه بافر
9. `close()`: بستن فایل

## بهترین روش استفاده (با context manager)

همیشه از بلوک `with` استفاده کنید:

```python
with open('file.txt', 'r', encoding='utf-8') as f:
    content = f.read()
    # پردازش محتوا
# فایل به صورت خودکار بسته می‌شود
```

## مثال‌های تابع open

### 1. خواندن فایل:
```python
with open('data.txt', 'r') as file:
    for line in file:
        print(line.strip())
```

### 2. نوشتن در فایل:
```python
with open('output.txt', 'w') as file:
    file.write('متن جدید\n')
    file.writelines(['خط اول\n', 'خط دوم\n'])
```

### 3. کار با فایل‌های باینری:
```python
with open('image.jpg', 'rb') as file:
    data = file.read()
```

### 4. مدیریت خطاها:
```python
try:
    with open('data.txt', 'r', encoding='utf-8') as file:
        content = file.read()
except FileNotFoundError:
    print("فایل وجود ندارد!")
except PermissionError:
    print("دسترسی مجاز نیست!")
except UnicodeDecodeError:
    print("مشکل در کدگذاری فایل!")
```

## نکات مهم و بهترین روش‌ها

1. همیشه از `with` استفاده کنید تا فایل به صورت خودکار بسته شود
2. برای فایل‌های بزرگ، به جای `read()` از خواندن خط به خط استفاده کنید
3. برای متن‌های فارسی حتماً encoding را روی `'utf-8'` تنظیم کنید
4. برای فایل‌های غیرمتنی از حالت باینری (`'b'`) استفاده کنید
5. قبل از کار با فایل، از وجود آن مطمئن شوید
6. پس از اتمام کار با فایل، آن را ببندید (اگر از `with` استفاده نمی‌کنید)