# **_vscode_**

- [**_vscode_**](#vscode)
- [عمل گر مقایسه ای](#عمل-گر-مقایسه-ای)
- [عملگرهای انتساب](#عملگرهای-انتساب)
- [عملگرهای منطقی](#عملگرهای-منطقی)
- [**split**](#split)
- [join](#join)
- [کاراکتر بک‌اسلش (\\)](#کاراکتر-بکاسلش-)
- [تکه بندی](#تکه-بندی)
    - [(f-string)فرمت دهی رشته با](#f-stringفرمت-دهی-رشته-با)
- [لیست](#لیست)
    - [ویژگی‌های کلیدی:](#ویژگیهای-کلیدی)
    - [دستورات پرکاربرد](#دستورات-پرکاربرد)
- [دیکشنری](#دیکشنری)
  - [تعریف دیکشنری](#تعریف-دیکشنری)
  - [ویژگی‌های کلیدی:](#ویژگیهای-کلیدی-1)
  - [روش‌های ایجاد دیکشنری:](#روشهای-ایجاد-دیکشنری)
  - [متدهای مهم:](#متدهای-مهم)
  - [مثال پیشرفته:](#مثال-پیشرفته)
- [حلقه](#حلقه)
  - [انواع حلقه‌ها :](#انواع-حلقهها-)
    - [1. حلقه `for` (برای تکرار روی دنباله‌ها)](#1-حلقه-for-برای-تکرار-روی-دنبالهها)
    - [2. حلقه `while` (برای تکرار شرطی)](#2-حلقه-while-برای-تکرار-شرطی)
  - [کنترل جریان حلقه‌ها](#کنترل-جریان-حلقهها)
    - [1. `break` (خروج از حلقه)](#1-break-خروج-از-حلقه)
    - [2. `continue` (رد کردن یک تکرار)](#2-continue-رد-کردن-یک-تکرار)
    - [3. `else` (پس از اتمام حلقه)](#3-else-پس-از-اتمام-حلقه)
    - [4. enumerate](#4-enumerate)
  - [تکنیک‌های پیشرفته](#تکنیکهای-پیشرفته)
    - [1. حلقه با `range()`](#1-حلقه-با-range)
    - [2. حلقه روی دیکشنری](#2-حلقه-روی-دیکشنری)
    - [3. حلقه‌های تو در تو](#3-حلقههای-تو-در-تو)
    - [4. فهرست‌سازی (List Comprehension)](#4-فهرستسازی-list-comprehension)
  - [نکات مهم:](#نکات-مهم)
  - [مثال کاربردی:](#مثال-کاربردی)
- [zip](#zip)
- [تابع](#تابع)
    - [1. برای تعریف تابع از کلمه کلیدی `def` استفاده می‌شود:](#1-برای-تعریف-تابع-از-کلمه-کلیدی-def-استفاده-میشود)
    - [**2.انواع پارامترها**](#2انواع-پارامترها)
      - [**الف) پارامترهای معمولی**](#الف-پارامترهای-معمولی)
      - [**ب) پارامترهای نام‌دار (Keyword Arguments)**](#ب-پارامترهای-نامدار-keyword-arguments)
      - [\*\*ج) پارامترهای نامحدود (`*args` و `**kwargs`)\*\*](#ج-پارامترهای-نامحدود-args-و-kwargs)
    - [**3. return**](#3-return)
    - [**4. توابع بازگشتی (Recursive)**](#4-توابع-بازگشتی-recursive)
    - [**5. توابع لامبدا (Lambda)**](#5-توابع-لامبدا-lambda)
    - [**6. دکوراتورها (Decorators)**](#6-دکوراتورها-decorators)
    - [مثال](#مثال)
    - [**نکات مهم:**](#نکات-مهم-1)
- [یادداشت تابع (function annotation)](#یادداشت-تابع-function-annotation)
  - [مثال](#مثال-1)
- [توابع لامبدا](#توابع-لامبدا)
  - [1. ساختار توابع لامدا:](#1-ساختار-توابع-لامدا)
  - [2. دستورات لامدا](#2-دستورات-لامدا)
    - [1. تابع map:](#1-تابع-map)
    - [2. تابع filter:](#2-تابع-filter)
    - [3. تابع reduce:](#3-تابع-reduce)
    - [4. تابع sorted:](#4-تابع-sorted)
- [pass](#pass)
- [DocString](#docstring)
- [**تکرار (Iteration)**](#تکرار-iteration)
  - [**1. حلقه `for` — تکرار بر روی عناصر یک دنباله**](#1-حلقه-for--تکرار-بر-روی-عناصر-یک-دنباله)
    - [**سینتکس پایه:**](#سینتکس-پایه)
    - [**مثال‌ها:**](#مثالها)
      - [**الف) تکرار روی لیست**](#الف-تکرار-روی-لیست)
      - [**ب) تکرار روی رشته**](#ب-تکرار-روی-رشته)
      - [**ج) تکرار روی دیکشنری**](#ج-تکرار-روی-دیکشنری)
  - [**2. حلقه `while` — تکرار تا زمانی که شرط برقرار است**](#2-حلقه-while--تکرار-تا-زمانی-که-شرط-برقرار-است)
    - [**سینتکس پایه:**](#سینتکس-پایه-1)
    - [**مثال‌ها:**](#مثالها-1)
      - [**الف) شمارش معکوس**](#الف-شمارش-معکوس)
      - [**ب) دریافت ورودی تا زمانی که کاربر "exit" وارد کند**](#ب-دریافت-ورودی-تا-زمانی-که-کاربر-exit-وارد-کند)
  - [**3. کنترل جریان حلقه‌ها (`break`, `continue`, `else`)**](#3-کنترل-جریان-حلقهها-break-continue-else)
    - [**الف) `break` — خروج زودهنگام از حلقه**](#الف-break--خروج-زودهنگام-از-حلقه)
    - [**ب) `continue` — رد کردن یک تکرار**](#ب-continue--رد-کردن-یک-تکرار)
    - [**ج) `else` — اجرای کد پس از اتمام حلقه**](#ج-else--اجرای-کد-پس-از-اتمام-حلقه)
  - [**4. توابع تکرارپذیر (`range`, `enumerate`, `zip`)**](#4-توابع-تکرارپذیر-range-enumerate-zip)
    - [**الف) `range()` — تولید دنباله‌ای از اعداد**](#الف-range--تولید-دنبالهای-از-اعداد)
    - [**ب) `enumerate()` — دریافت ایندکس و مقدار**](#ب-enumerate--دریافت-ایندکس-و-مقدار)
    - [**ج) `zip()` — ترکیب دو لیست**](#ج-zip--ترکیب-دو-لیست)
  - [**5. List Comprehension — تکرار فشرده برای ساخت لیست**](#5-list-comprehension--تکرار-فشرده-برای-ساخت-لیست)
  - [**6. توابع بازگشتی (Recursive Functions)**](#6-توابع-بازگشتی-recursive-functions)
  - [**نتیجه‌گیری**](#نتیجهگیری)
- [Decorator](#decorator)
  - [دکوراتور چیست؟](#دکوراتور-چیست)
  - [دکوراتورهای استاندارد پایتون](#دکوراتورهای-استاندارد-پایتون)
  - [کاربردهای رایج دکوراتورها](#کاربردهای-رایج-دکوراتورها)
  - [فرم کلی](#فرم-کلی)
  - [مثال :](#مثال-)
  - [نکات مهم](#نکات-مهم-2)
  - [جمع‌بندی](#جمعبندی)
- [ژنراتورها (Generators)](#ژنراتورها-generators)
  - [1. ژنراتور](#1-ژنراتور)
  - [2. ساخت ژنراتور](#2-ساخت-ژنراتور)
    - [تابع ژنراتور (با `yield`)](#تابع-ژنراتور-با-yield)
  - [3. تفاوت ژنراتور با لیست معمولی](#3-تفاوت-ژنراتور-با-لیست-معمولی)
  - [4. مثال](#4-مثال)
    - [الف) پردازش فایل‌های حجیم](#الف-پردازش-فایلهای-حجیم)
    - [ب) تولید دنباله‌های ریاضی](#ب-تولید-دنبالههای-ریاضی)
    - [ج) خط لوله پردازش داده (Pipeline)](#ج-خط-لوله-پردازش-داده-pipeline)
    - [ه) ژنراتور برای فیلتر کردن داده‌ها](#ه-ژنراتور-برای-فیلتر-کردن-دادهها)
    - [مثال های بیشتر](#مثال-های-بیشتر)
  - [5. تفاوت `yield` و `return`](#5-تفاوت-yield-و-return)
  - [خلاصه](#خلاصه)
- [متت های لیست](#متت-های-لیست)
    - [**۱. متدهای اضافه کردن عناصر**](#۱-متدهای-اضافه-کردن-عناصر)
    - [**۲. متدهای حذف عناصر**](#۲-متدهای-حذف-عناصر)
    - [**۳. متدهای جستجو و اطلاعات**](#۳-متدهای-جستجو-و-اطلاعات)
    - [**۴. متدهای مرتب‌سازی و تغییر ترتیب**](#۴-متدهای-مرتبسازی-و-تغییر-ترتیب)
    - [تفاوت `reverse()` و `reversed()`:](#تفاوت-reverse-و-reversed)
    - [کاربرد `reversed()`:](#کاربرد-reversed)
    - [مثال‌های بیشتر:](#مثالهای-بیشتر)
    - [**۵. متدهای کپی و ایجاد لیست جدید**](#۵-متدهای-کپی-و-ایجاد-لیست-جدید)
    - [**۶. سایر متدهای مفید**](#۶-سایر-متدهای-مفید)
    - [**جمع‌بندی**](#جمعبندی-1)
- [متد های تاپل و مجموعه ها](#متد-های-تاپل-و-مجموعه-ها)
  - [**متدهای تاپل (Tuple Methods)**](#متدهای-تاپل-tuple-methods)
    - [۱- **`count(x)`**](#۱--countx)
    - [۲- **`index(x)`**](#۲--indexx)
    - [**نکته مهم:**](#نکته-مهم)
  - [**متدهای مجموعه (Set Methods)**](#متدهای-مجموعه-set-methods)
    - [۱- **اضافه و حذف عناصر**](#۱--اضافه-و-حذف-عناصر)
    - [۲- **عملیات مجموعه‌ها**](#۲--عملیات-مجموعهها)
    - [۳- **متدهای بررسی**](#۳--متدهای-بررسی)
      - [**4- متد `difference()`**](#4--متد-difference)
      - [**5- متد `difference_update()`**](#5--متد-difference_update)
      - [**6- متد `isdisjoint()`**](#6--متد-isdisjoint)
    - [**جمع‌بندی متدهای مجموعه (Set)**](#جمعبندی-متدهای-مجموعه-set)
    - [**جمع‌بندی:**](#جمعبندی-2)

# عمل گر مقایسه ای

- == : equal
- != : not equal
- .> : greatel than //همان
- < : less than
- .>= : greater than or equal to //کوچیک تر مساوی
- <= : less than or equal to

# عملگرهای انتساب

- += x=x+2
- -= x=x-2
- *= x=x*2
- /= x=x/2
- %= x=x%2 //باقی مانده
- //= x=x//2
- **= x=x**2 //توان 2

```
    x = 4
    x += 2;
    print(x);       //پرینت می کنه 6
```

# عملگرهای منطقی

![alt text](<picture-lening/عملگرهای منطقی.png>)

- ما می توان با دستور + دو تا رشته را به هم جمع کنیم

  > print("x"+"y")

- دستور را چندین بار تکرار میکند

  > print(4\*"alireza")

- اخرین رقم ان عدد را نشان می دهد
  print(هر عددی %10)

- به میزانی که عدد گذاشتیم عدد را رند می کند

  > print(round(motegaier, 2))

- متوجه میشیم که یک متغیر جزو کدام نوع داده هست

  > print(isinstance(نوع متغیر , متغیر))

- تعداد تکرار را میشمرد

  > [رشته].count()

- فضای خالی از سمت راست را پاک می کند

  > [رشته].rstrip

- پیدا می کند از داخل رشته

  > [رشته].find

- یک کارکتر چند بار تکرار شده

  > تابع.count('یک کارکتر از تابع')

- برسی می کند که یک تابع با یک کارکتر خاص به اتمام رسیده است یا خیر

  > تابع. endswith("کارکتر")

- برسی می کند که یک تابع با یک کارکتر خاص شروع شده یا خیر

  > تابع. startswith("کارکتر")

- کارکتر را پیدا میکند
- ایندکس ان (از سمت چپ شروع می شود)

  > تابع . find ('کارکتر')

- نشان میده که کل کارکتر فقط عدد است یا نه

  > تابع . isnumeric()

- > تابع . replace ('کارکتر که می خوایم عوض بشه ', 'کارکتری که جایگذاری بشه')

- اگر داخل پرانتز خالی باشد فاصله در نظر می گیرد ; فاصله های اضاقی از ابتدا و انتهای را پاک می کند

  > تابع . strip()

- از سمت چپ فقط پاک میکند

  > تابع . lreplace

- مقدار تکرار یک چیز را می شمارد

  > c . count(تابع)

- یونیکد

  > ord()

- مقادیر را مرتب می کند

  > sorted()

- نوع رشته را مشخص میکند
  > (type(رشته))

# **split**

- این دستور ترکیبی از دو عمل اصلی است که برای دریافت ورودی از کاربر و تقسیم آن به بخش‌های جداگانه استفاده می‌شود:

- .split()

  - متدی برای رشته‌ها که آنها را بر اساس جداکننده (پیش‌فرض: فاصله) تقسیم می‌کند

  - نتیجه یک لیست از زیررشته‌ها است

  ```py
  data = input("enter: ").split(',')
   ورودی: "علی,رضا,مریم"
   → ['علی', 'رضا', 'مریم']
  ```

# join

- دو تابع را به یک دیگر متصل می کند

```py
s = "*"
l + ["a" , "b" , "c"]
print(s.join(l))
===> a*b*c
```

# کاراکتر بک‌اسلش (\\)

- (\دستور) ----- کار این دستور لغو کردن دستورات است

- \n ------ می رود خط بعدی
- \\\ ----- c:\alireza\new ==> c:\alireza\\\new
- \t ------- یک تب فاصله می دهد
- اگر قبل رشته دستور (r')بزنیم تمام دستورات \ را لغو می کند
- \b ------ حرف قبلی را پاک می کند

# تکه بندی

- برای اینکه بتوانیم ایندکس یک رشته را بگیریم

  - (s[ایندکس])

- برای چاپ کردن یک بخشی از رشته

  - (رشته[ایندکس: ایندکس])
  - اگر در هر قسمت ایندکس نگذاریم تا اخر رشته را استفاده می کند

- طول گام را مشخص می کند

  - ([گام: ایندکس :ایندکس]رشته)

- (len(رشته)) سایز رشته را نشان می دهد

- (رشته[::]) رشته را معکوس می کند

### (f-string)فرمت دهی رشته با

```py
name = "alireza"
age = 18

msg =(
f"name: {name}\n"
f'age: {age}\n
     )

print(msg)

autput= name: alireza
       age:18
```

# لیست

لیست یک ساختار داده‌ی تغییرپذیر و ترتیبی در پایتون است که می‌تواند عناصر مختلف را ذخیره کند .

> my_list = [1, "دو", 3.0, True] # ایجاد لیست با انواع داده مختلف

### ویژگی‌های کلیدی:

1. تغییرپذیر (Mutable): محتوا قابل تغییر است
   > my_list[0] = 10 # تغییر اولین عنصر
2. ترتیبی (Ordered): ترتیب عناصر حفظ می‌شود
3. پشتیبانی از انواع داده مختلف:
   > mixed = [1, "text", 3.14, [1, 2]] # لیست در لیست

- `متدهای پرکاربرد`

```
1.  print(my_list[0])  # اولین عنصر (ایندکس 0)
2.  print(my_list[-1]) # آخرین عنصر
3. print(my_list[1:3])  # عناصر از ایندکس 1 تا 2
4. my_list.append(4)       # اضافه کردن به انتها
5. my_list.insert(1, 1.5)  # درج در موقعیت خاص
6. my_list.remove("دو")    # حذف مقدار خاص
7. popped = my_list.pop()  # حذف و بازگرداندن آخرین عنصر
8. len(my_list)      # طول لیست
9. my_list.sort()    # مرتب‌سازی
10. my_list.reverse() # معکوس کردن ترتیب
```

- `نکته`
  - با گذاشتن ستاره قبل از یک کارکتر کارکتر را تبدیل به لیست میکند

```py
a, b, *c = [1, 2, 3, 4, 5, 6]
print(a, b, c)

autput = 1      2       [3, 4, 5, 6]
```

### دستورات پرکاربرد

1. **reversed** = یکی از لیست ها را معکوس می کند

```python
x = ['Alice', 'Bob', 'Charlie']
y = [25, 30, 35]
for i, j in reversed(x,y):
   print(i)
```

2. **sorted**
   (به ترتیب حرف الف با)تمامی لیست را مرتب می کند

```python
x = ['Alice', 'Bob', 'Charlie']
y = [25, 30, 35]
for i, j in sorted(x):
    print(i)
```

3. **random**
   min + (random \* (max - min)) عدد رندوم در بازه ای که میخوایم تولید می کند

- random.uniform یک تابع از ماژول random است که برای تولید اعداد تصادفی با توزیع یکنواخت پیوسته (Continuous Uniform Distribution) استفاده می‌شود. این تابع یک عدد اعشاری تصادفی در بازه مشخص شده ([a, b]) برمی‌گرداند که همه مقادیر در این بازه احتمال یکسانی دارند.

- تفاوت random.uniform با random.random:

  - random.random() فقط اعداد بین ۰.۰ تا ۱.۰ تولید می‌کند.

  - random.uniform(a, b) اعداد بین a تا b (شامل a و b) تولید می‌کند.

```python
import random

# با random.random
rand1 = random.random()  # مثلاً 0.74321

# با random.uniform
rand2 = random.uniform(5, 10)  # مثلاً 7.8321
```

```python
#مثال
#(تولید عدد رندوم در بازه بیت 5 تا 10 )
from random import random
for _ in range(10):
    print(5 + (random() * (10 - 5)))

#مثال 2
from random import random
for _ in range(10):
    print(5 + (random() * (10)))

#random uniform

from random import random, uniform
for _ in range(10):
    print(uniform(5,10))

#تولید عدد رندوم intger

from random import randint
for _ in range(10):
    print(randint(5, 16))

#تولید عدد رندوم با طول گام

from random import randrange
for _ in range(10):
    print(randrange(5, 50, 3))


#از بازه موجود به صورت رندوم یک را انتخاب می کند
from random import choice
x = ["a", "b", "c","d"]
for _ in range(10):
    print(choice(x))

#یک زیر لیست از لیست درست می کند

from random import sample
x = ["a", "b", "c","d"]
print(sample(x, 2))
print(x)
```

`نکته:`
اگر می خواهیم بعد از تولید یک زیر لیست , زیر لیست تغیر نکند از دستور
(**seed**) استقاده می کنیم

```python
from random import sample, seed
x = ["a", "b", "c","d"]
seed(10)
print(sample(x, 2))
print(x)
```

4.  **shuffle**
    بور می زند یعنی لبست من را شانسی بور می زند

```python
from random import shuffle
x = ["a", "b", "c","d"]
shuffle(x)
print(x)
```

# دیکشنری

## تعریف دیکشنری

- دیکشنری (Dictionary) یک ساختار داده‌ی **تغییرپذیر**، **نامرتب** و **ایندکس‌گذاری شده با کلید** در پایتون است که داده‌ها را به صورت جفت‌های `کلید: مقدار` ذخیره می‌کند.

```python
my_dict = {"name": "علی", "age": 25, "city": "تهران"}
```

## ویژگی‌های کلیدی:

1. **تغییرپذیر (Mutable)**: مقادیر قابل تغییر هستند
2. **نامرتب (Unordered)**: ترتیب عناصر حفظ نمی‌شود (تا پایتون 3.6)
3. **عدم اجازه کلید تکراری**: هر کلید فقط یک بار می‌تواند وجود داشته باشد

## روش‌های ایجاد دیکشنری:

1. روش مستقیم:

   ```python
   person = {"name": "رضا", "age": 30}
   ```

2. استفاده از تابع `dict()`:

   ```python
   person = dict(name="نازنین", age=28)
   ```

3. از لیست تاپل‌ها:
   ```python
   pairs = [("one", 1), ("two", 2)]
   numbers = dict(pairs)
   ```

## متدهای مهم:

- اگر بخواهیم یک متغیر تعریف کنیم که هیچ متغیر خاصی ندارد از \***\*none type\*\*** استفاده می کنیم
  تابع = none

```python
keys = person.keys()    # لیست کلیدها
values = person.values()  # لیست مقادیر
items = person.items()   # لیست جفت‌های کلید-مقدار
```

## مثال پیشرفته:

```python
students = {
    1001: {"name": "علی", "grades": [18, 20, 16]},
    1002: {"name": "زهرا", "grades": [19, 17, 20]}
}

# محاسبه میانگین نمرات
for student_id, info in students.items():
    avg = sum(info["grades"]) / len(info["grades"])
    print(f"{info['name']}: {avg:.2f}")
```

# حلقه

## انواع حلقه‌ها :

### 1. حلقه `for` (برای تکرار روی دنباله‌ها)

```python
for item in sequence:
    # دستورات
```

مثال:

```python
fruits = ["سیب", "پرتقال", "موز"]
for fruit in fruits:
    print(fruit)
```

### 2. حلقه `while` (برای تکرار شرطی)

```python
while condition:
    # دستورات
```

مثال:

```python
count = 0
while count < 5:
    print(count)
    count += 1
```

مثال 2:

```
n = int(input("x = "))
while n < 100:
    if n % 2 == 0 :
     print(n)
n += 1
اعداد زوج را چاپ می کند
```

## کنترل جریان حلقه‌ها

### 1. `break` (خروج از حلقه)

```python
for num in range(10):
    if num == 5:
        break
    print(num)
```

```python
n = float(input("n:"))
m = n
while True:
    s = input("do tou cantinue?")
    if s.lower() == "no":
        break
    n = float(input("n:"))
    if n < m :
        m = n
        print(m,"min:")
```

### 2. `continue` (رد کردن یک تکرار)

```python
for num in range(10):
    if num % 2 == 0:
        continue
    print(num)  # فقط اعداد فرد
```

### 3. `else` (پس از اتمام حلقه)

```python
for num in range(3):
    print(num)
else:
    print("حلقه کامل اجرا شد")
```

```python
i = 0
while i <10:
   i += 1
   if i % 3 == 0:
       break
    print(i)
else:
    print("ok")
autput
1
2
```

```python
n = int(input("n:"))
i = 2
if n > 1:
    while i < n:
        if n % i == 0:
            print(n,"is nat prime number")
            break
        i += 1
    else:
        print(n, "not prime number")
else:
    print(n,"is a not prime number")
#برسی می کند عدد اول هست یا نه
```

### 4. enumerate

تابع **enumerate** در پایتون به شما اجازه می‌دهد تا همزمان به اندیس و مقدار عناصر یک لیست دسترسی داشته باشید.

```python
  l = ["a", "b", "c", "d"]
  for i ,j enumerate(l):
     print(i, ":", j)

  autput
  0 : a
  1 : b
  3 : c
  4 : d
```

## تکنیک‌های پیشرفته

### 1. حلقه با `range()`

اگر بخواهیم در حلقه (for )یک رنج تعریف کنیم از دستور **range**استفاده می کنیم

- range(طول گام , بازه )

```python
for i in range(5):       # 0 تا 4
for i in range(2, 6):    # 2 تا 5
for i in range(1, 10, 2): # 1 تا 9 با گام 2
```

مثال :

```python
   l = input("name:").split("-")
   print(l)
   for i in range(0, len(l)):
     print(i, L[i])
```

### 2. حلقه روی دیکشنری

```python
person = {"name": "علی", "age": 30}

for key in person:         # کلیدها
for value in person.values(): # مقادیر
for key, value in person.items(): # جفت‌ها
```

### 3. حلقه‌های تو در تو

```python
for i in range(3):
    for j in range(2):
        print(f"({i}, {j})")
```

### 4. فهرست‌سازی (List Comprehension)

```python
squares = [x**2 for x in range(10)]
```

## نکات مهم:

- از حلقه `for` برای تکرار روی اشیاء قابل پیمایش استفاده کنید
- از حلقه `while` وقتی تعداد تکرارها نامشخص است استفاده کنید
- از `break` و `continue` برای کنترل جریان استفاده کنید
- `range()` یک دنباله اعداد ایجاد می‌کند

## مثال کاربردی:

```python
# محاسبه فاکتوریل
n = 5
factorial = 1
for i in range(1, n+1):
    factorial *= i
print(f"!{n} = {factorial}")
```

# zip

دستور zip در پایتون دو یا چند لیست را گرفته و آن‌ها را به صورت زوج‌های (tuple) ترکیب می‌کند.

```python
x = ['Alice', 'Bob', 'Charlie']
y = [25, 30, 35]
for i, j in zip(x,y):
   print("name", i, "age", j)
```

# تابع

تابع (Function) در پایتون یک بلوک کد قابل استفاده مجدد است که یک کار خاص را انجام می‌دهد. توابع به سازماندهی کد، جلوگیری از تکرار و افزایش خوانایی کمک می‌کنند.

### 1. برای تعریف تابع از کلمه کلیدی `def` استفاده می‌شود:

```python
def نام_تابع(پارامترها):
    # بدنه تابع
    return نتیجه  # اختیاری
```

---

### **2.انواع پارامترها**

#### **الف) پارامترهای معمولی**

```python
def add(a, b):
    return a + b

print(add(3, 5))  # خروجی: 8
```

#### **ب) پارامترهای نام‌دار (Keyword Arguments)**

```python
def person_info(name, age):
    print(f"نام: {name}, سن: {age}")

person_info(age=25, name="رضا")  # ترتیب مهم نیست!
```

#### **ج) پارامترهای نامحدود (`*args` و `**kwargs`)\*\*

- `*args` برای دریافت لیستی از مقادیر:

  ```python
  def sum_all(*numbers):
      return sum(numbers)

  print(sum_all(1, 2, 3))  # خروجی: 6
  ```

- `**kwargs` برای دریافت دیکشنری از پارامترهای نام‌دار:

  ```python
  def show_info(**details):
      for key, value in details.items():
          print(f"{key}: {value}")

  show_info(name="مریم", age=30, city="تهران")
  ```

---

### **3. return**

اگر ما از تابع استفاده کنیم و دستور(return) را استفاده نکنیم و بعد تابع را صدا بزنیم اخر کلمه `none` را چاپ می کند

- همیشه لازم نیست از (return)استفاده شود

```py
def f():
    x = int(input("x :"))
    print(2 * x + 1)
f()
```

### **4. توابع بازگشتی (Recursive)**

تابعی که خودش را فراخوانی می‌کند.  
**مثال: محاسبه فاکتوریل:**

```python
def factorial(n):
    return 1 if n == 1 else n * factorial(n - 1)

print(factorial(5))  # 120
```
```py
#تابع عادی
def fact(x):
  f = 1
    for i in range(1, x+1):
      f += i
    return f
#تابع بازگشتی
def rec_fact(x):
  if x == 0 or x == 1:
    return 1
  return x * fact(x -1)
```

---

### **5. توابع لامبدا (Lambda)**

توابع کوچک و بی‌نام که با `lambda` تعریف می‌شوند:

```python
square = lambda x: x ** 2
print(square(4))  # 16
```

**کاربرد در `map` و `filter`:**

```python
numbers = [1, 2, 3]
squared = list(map(lambda x: x ** 2, numbers))  # [1, 4, 9]
```

---

### **6. دکوراتورها (Decorators)**

برای تغییر رفتار تابع بدون تغییر کد اصلی استفاده می‌شوند:

```python
def logger(func):
    def wrapper(*args, **kwargs):
        print(f"اجرای تابع {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@logger
def greet(name):
    print(f"سلام {name}!")

greet("علی")  # ابتدا "اجرای تابع greet" چاپ می‌شود.
```

---

### مثال

```py
f(x)= 2x+1
def f(x):
    return 2 x + 1
print(f(1))

#مثال 2:
def f(x):
    return 2 * x + 1
y = int(input("y :"))
f(y)
print(f(y))
#مثال 3:
def f():
    x = int(input("x :"))
    return 2 * x + 1
print(f())
```

---

### **نکات مهم:**

1. نام تابع باید توصیفی باشد (مثل `calculate_area` به جای `func1`).
2. از توابع برای تقسیم کد به بخش‌های منطقی استفاده کنید.
3. توابع باید تا حد امکان مستقل از متغیرهای خارجی باشند.

# یادداشت تابع (function annotation)

- در مقابل، پایتون به عنوان یک زبان داینامیک تایپ، به شما اجازه می‌دهد نوع پارامترها را مشخص نکنید و ارسال نوع داده اشتباه را در زمان اجرا تشخیص می‌دهد. این موضوع گاهی اوقات می‌تواند مشکل‌ساز باشد، زیرا ممکن است خطای نوع داده تا زمان اجرای برنامه مشخص نشود.

- برای حل این مشکل، پایتون از یادداشت تابع (Function Annotations) استفاده می‌کند. با استفاده از یادداشت تابع، می‌توان نوع پارامترها و نوع خروجی تابع را مشخص کرد.

- نکته مهم این است که یادداشت تابع در زمان اجرای عادی پایتون، هیچ تاثیری در عملکرد برنامه ندارد و صرفا برای راهنمایی برنامه‌نویس و ابزارهای توسعه مانند IDEها و Linterها استفاده می‌شود. برای مثال، PyCharm با استفاده از یادداشت تابع، می‌تواند خطاهای نوع داده را قبل از اجرا به شما نشان دهد.

- برای تشخیص خطاهای نوع داده در زمان اجرا، می‌توانید از ماژول mypy استفاده کنید. این ماژول با بررسی یادداشت تابع، خطاهای نوع داده را در زمان اجرا شناسایی می‌کند.

- نحوه تعریف نوع پارامترها با استفاده از یادداشت تابع به این صورت است که بعد از نام پارامتر، دو نقطه قرار داده و سپس نوع داده مورد نظر را می‌نویسیم.

- برای تعریف نوع خروجی تابع، باید بین دو نقطه و پرانتز تابع، یک فلش به سمت راست (->) قرار داده و سپس نوع داده خروجی را بنویسیم.

- همچنین می‌توان برای پارامترهای تابع، مقادیر پیش‌فرض تعیین کرد. در این صورت، اگر هنگام فراخوانی تابع، مقداری برای پارامتر ارسال نشود، از مقدار پیش‌فرض استفاده خواهد شد.

- برای مشاهده یادداشت تابع، می‌توان از **annotations** استفاده کرد.

- در نهایت، می‌توان از انواع داده مختلف مانند دیکشنری، لیست و تاپل در یادداشت تابع استفاده کرد.

- به طور کلی، استفاده از یادداشت تابع در پایتون، می‌تواند به خوانایی کد و جلوگیری از خطاهای نوع داده کمک کند.

## مثال

```py
#مثال ۱: تابع ساده با ورودی و خروجی عددی
def func(x: int, y: int, z: int) -> int:
    return x + y + z

print(func(1, 2, 3))
#در این مثال، تابع func سه پارامتر ورودی از نوع int دریافت می‌کند و خروجی آن نیز از نوع int است.

# مثال ۲: تابع با مقدار پیش‌فرض
def func(x: int = 10, y: int = 9, z: int = 5):
print(x, y, z)

func()
#در این مثال، برای هر یک از پارامترهای تابع func یک مقدار پیش‌فرض تعیین شده است. اگر تابع بدون ارسال آرگومان فراخوانی شود، از مقادیر پیش‌فرض استفاده خواهد شد.
#مثال ۳: تابع با نوع داده دیکشنری
def func(x: int, y: int, z: dict):
print(x)
print(y)
print(z)

func(1, 9, {})
#در این مثال، پارامتر z از نوع dict (دیکشنری) است.
# مثال ۴: تابع با نوع داده تاپل
def func(x: int, y: int, z: int) -> tuple:
    return (x+y+z, x, y, z)

print(func(1, 2, 5))
#در این مثال، نوع خروجی تابع func یک tuple (تاپل) است که شامل جمع سه عدد و خود اعداد می‌شود.


#    نکته: در تمامی این مثال‌ها، اگر نوع داده اشتباهی به تابع ارسال شود (مثلاً به جای عدد، رشته ارسال شود)، در زمان اجرای عادی پایتون خطایی رخ نمی‌دهد. اما اگر از ابزار mypy یا IDEهایی مانند PyCharm استفاده کنید، این خطاها قبل از اجرا یا در زمان اجرا شناسایی خواهند شد.
```

# توابع لامبدا

- لامبدا و کاربرد آن (map، filter، reduce و sorted)
- مفهوم توابع لامدا به عنوان توابع ناشناس و مختصر در پایتون توضیح داده می‌شود. این توابع برای مواقعی که نیاز به یک تابع کوچک و یکبار مصرف داریم، مفید هستند.

## 1. ساختار توابع لامدا:

توابع لامدا با استفاده از کلمه کلیدی lambda تعریف می‌شوند و ساختار آنها به صورت زیر است:
lambda arguments: expression

- توابع لامبدا توابع ناشناسی هستند که در یک خط نوشته می‌شوند و اسم ندارند. [1، 2] این توابع برای زمانی که به تابعی کوچک و یکبار مصرف نیاز دارید مفید هستند.

- **نحوه نوشتن یک تابع لامبدا:**

ابتدا کلمه کلیدی "لامبدا" را می‌نویسیم. سپس ورودی‌های تابع را با کاما از هم جدا می‌کنیم. بعد از ورودی‌ها، دو نقطه قرار می‌دهیم و در جلوی دو نقطه عبارت یا بدنه تابع را می‌نویسیم. نیازی به نوشتن دستور "ریترن" نیست زیرا به طور خودکار عبارت بعد از دو نقطه را برمی‌گرداند.

- ### Arguments: ورودی‌های تابع که با کاما از هم جدا می‌شوند.

- ### Expression: عبارتی که قرار است توسط تابع اجرا شود و نتیجه آن برگردانده شود.

  **نکات مهم:**

      1. توابع لامدا نیازی به نام ندارند.

      2. بدنه این توابع فقط شامل یک عبارت است.

      3. نیازی به استفاده از دستور return نیست، زیرا عبارت به صورت خودکار برگردانده می‌شود.

  **کاربردهای توابع لامدا:**

-توابع لامدا در کنار توابع و نوع‌های داخلی پایتون مانند map، filter، reduce و sorted کاربردهای فراوانی دارند.

## 2. دستورات لامدا

### 1. تابع map:

-تابع map دو آرگومان دریافت می‌کند: یک تابع و یک لیست. این تابع، عناصر لیست را یکی‌یکی به تابع ارسال می‌کند و نتیجه هر عنصر را در لیست جدیدی قرار می‌دهد.

```py
new_list = list(map(lambda x: x**2, my_list))

#در این مثال، هر عنصر لیست my_list به توان دو رسانده شده و نتیجه در لیست new_list قرار می‌گیرد.
```

### 2. تابع filter:

- تابع filter نیز دو آرگومان دریافت می‌کند: یک تابع و یک لیست. این تابع، عناصر لیست را یکی‌یکی به تابع ارسال می‌کند و اگر نتیجه تابع True باشد، عنصر را در لیست جدیدی قرار می‌دهد و در غیر این صورت آن را حذف می‌کند.

```py
new_list = list(filter(lambda x: x > 5, my_list))

#در این مثال، فقط عناصری از لیست my_list که بزرگتر از 5 هستند در لیست new_list قرار می‌گیرند.
```

### 3. تابع reduce:

- تابع reduce دو ورودی دریافت می‌کند: یک تابع و یک لیست. این تابع، دو عنصر اول لیست را به تابع ارسال می‌کند و نتیجه آن را با عنصر سوم لیست به تابع ارسال می‌کند و این کار را تا آخرین عنصر لیست ادامه می‌دهد.

```py
from functools import reduce

sum_of_list = reduce(lambda x, y: x + y, my_list)

#در این مثال، reduce جمع همه عناصر لیست my_list را محاسبه می‌کند.
```

### 4. تابع sorted:

- تابع sorted یک لیست را به عنوان ورودی دریافت می‌کند و یک لیست مرتب شده بر می‌گرداند. این تابع همچنین می‌تواند یک آرگومان اختیاری به نام key دریافت کند که یک تابع است و برای مرتب‌سازی عناصر لیست استفاده می‌شود.

```py
sorted_list = sorted(my_list, key=lambda x: len(x))

#در این مثال، sorted لیست my_list را بر اساس طول رشته‌ها مرتب می‌کند.
```

---

```python
lambda x: x ** 2
#در این مثال، تابع یک ورودی (x) می‌گیرد و آن را به توان دو می‌رساند.
```

**کاربردهای لامبدا:**

- **مپ:**
  تابع `map` یک تابع و یک لیست را به عنوان ورودی می‌گیرد. این تابع، تابع ورودی را روی تک تک عناصر لیست اعمال کرده و لیست جدیدی با نتایج برمی‌گرداند.

**مثال:**

```python
my_list =
new_list = list(map(lambda x: x ** 2, my_list))
print(new_list)  # Output:
```

در این مثال، تابع لامبدا هر عنصر از لیست را به توان دو می‌رساند و `map` این تابع را روی تمام عناصر لیست `my_list` اعمال می‌کند. [4، 6]

- **فیلتر:**
  تابع `filter` یک تابع و یک لیست را به عنوان ورودی می‌گیرد. این تابع، عناصری از لیست را که تابع ورودی برای آنها مقدار `True` را برمی‌گرداند، نگه می‌دارد و بقیه را حذف می‌کند.

**مثال:**

```python
my_list =
new_list = list(filter(lambda x: x > 5, my_list))
print(new_list)  # Output:
```

در این مثال، تابع لامبدا بررسی می‌کند که آیا هر عنصر از لیست بزرگتر از 5 است یا خیر. [6، 7] `filter` فقط عناصری را که تابع لامبدا برای آنها `True` را برمی‌گرداند، در لیست `new_list` قرار می‌دهد. [6، 7]

- **ریدیوس:**
  تابع `reduce` یک تابع و یک لیست را به عنوان ورودی می‌گیرد. این تابع، دو عنصر از لیست را به تابع ورودی ارسال می‌کند و نتیجه را با عنصر بعدی لیست ترکیب می‌کند تا در نهایت یک نتیجه نهایی به دست آید.

**مثال:**

```python
from functools import reduce
my_list =
result = reduce(lambda x, y: x + y, my_list)
print(result)  # Output: 10
```

در این مثال، تابع لامبدا دو ورودی (x و y) را دریافت کرده و آنها را با هم جمع می‌کند. [9، 10] `reduce` از این تابع برای جمع کردن تمام عناصر لیست `my_list` استفاده می‌کند.

- **مرتب‌سازی:**
  تابع `sorted` یک لیست و یک تابع (اختیاری) را به عنوان ورودی می‌گیرد. این تابع، لیست را بر اساس خروجی تابع ورودی مرتب می‌کند.

**مثال:**

```python
my_list =
new_list = sorted(my_list, key=lambda x: x % 3)
print(new_list)  # Output:
```

در این مثال، تابع لامبدا باقی مانده تقسیم هر عنصر از لیست بر 3 را برمی‌گرداند. `sorted` از این تابع برای مرتب‌سازی لیست `my_list` استفاده می‌کند. [10، 12]

**_نکته:_** در همه این مثال‌ها، به جای تعریف جداگانه تابع و ارسال آن به توابع `map`، `filter`، `reduce` و `sorted`، از توابع لامبدا برای تعریف تابع به صورت inline استفاده شده است. [6، 8، 10، 12]

# pass

از این دستور زمانی استفاده می کنیم که نمی خواهیم بدنه یک تابع یا حلقه ای را بنویسیم و بعدا بدنه ان را می نویسیم از این دستور استفاده می کنیم

- خلاصه‌ای از ویدیو به همراه دستورات مورد نیاز

# DocString

**هدف از داک‌استرینگ توضیح عملکرد یک تابع، کلاس یا ماژول برای کاربران و برنامه‌نویسانی است که ممکن است کد را ننوشته باشند.**

**داک‌استرینگ چگونه تعریف می‌شود؟**

- برای تعریف داک‌استرینگ، کافیست در خط اول بعد از تعریف تابع، کلاس یا ماژول، یک رشته با سه علامت نقل قول ("") یا سه علامت نقل قول دوتایی (""") بنویسید.
- توصیه می‌شود از سه علامت نقل قول دوتایی استفاده شود.
- متن داک‌استرینگ می‌تواند شامل خلاصه‌ای از عملکرد، پارامترهای ورودی، خروجی‌ها و توضیحات اضافی باشد.

**مثال:**

```python
def max_3(x, y, z):
   """
  این تابع سه عدد دریافت می‌کند و بزرگترین آنها را برمی‌گرداند.

  Args:
      x (int): اولین عدد
      y (int): دومین عدد
      z (int): سومین عدد

  Returns:
      int: بزرگترین عدد از بین سه عدد ورودی
  """
  # کد تابع
  return max(x, y, z)
```

**نکات مهم:**

- داک‌استرینگ باید اولین خط بعد از تعریف تابع، کلاس یا ماژول باشد.
- استفاده از داک‌استرینگ اختیاری است، اما توصیه می‌شود برای توابع، کلاس‌ها و ماژول‌ها داک‌استرینگ بنویسید.
- داک‌استرینگ با کامنت فرق دارد. کامنت برای توضیح نحوه کار کد برای برنامه‌نویسان است، در حالی که داک‌استرینگ برای توضیح عملکرد کد برای کاربران است.

**دستورات مورد نیاز برای دسترسی به داک‌استرینگ:**

- با استفاده از اتریبیوت `__doc__` :

```python
print(max_3.__doc__)
```

- با استفاده از تابع `help()` :

```python
help(max_3)
```

اکثر توابع داخلی پایتون دارای داک‌استرینگ هستند. برای مثال:

```python
print(len.__doc__)
print(print.__doc__)
print(max.__doc__)
```

# **تکرار (Iteration)**

در پایتون، **تکرار (Iteration)** به فرآیند اجرای مکرر یک بلوک کد گفته می‌شود. این کار معمولاً با استفاده از **حلقه‌ها (Loops)** یا **توابع بازگشتی (Recursive Functions)** انجام می‌شود. در اینجا به بررسی روش‌های مختلف تکرار در پایتون می‌پردازیم.

---

## **1. حلقه `for` — تکرار بر روی عناصر یک دنباله**

حلقه `for` برای **تکرار روی عناصر یک دنباله** (مانند لیست، رشته، تاپل، دیکشنری و ...) استفاده می‌شود.

### **سینتکس پایه:**

```python
for متغیر in دنباله:
    # کدی که تکرار می‌شود
```

### **مثال‌ها:**

#### **الف) تکرار روی لیست**

```python
fruits = ["سیب", "پرتقال", "موز"]
for fruit in fruits:
    print(fruit)
```

**خروجی:**

```
سیب
پرتقال
موز
```

#### **ب) تکرار روی رشته**

```python
name = "پایتون"
for char in name:
    print(char)
```

**خروجی:**

```
پ
ا
ی
ت
و
ن
```

#### **ج) تکرار روی دیکشنری**

```python
person = {"name": "علی", "age": 25, "city": "تهران"}
for key, value in person.items():
    print(f"{key}: {value}")
```

**خروجی:**

```
name: علی
age: 25
city: تهران
```

---

## **2. حلقه `while` — تکرار تا زمانی که شرط برقرار است**

حلقه `while` تا زمانی که **شرط آن `True` باشد** اجرا می‌شود.

### **سینتکس پایه:**

```python
while شرط:
    # کدی که تکرار می‌شود
```

### **مثال‌ها:**

#### **الف) شمارش معکوس**

```python
count = 5
while count > 0:
    print(count)
    count -= 1
```

**خروجی:**

```
5
4
3
2
1
```

#### **ب) دریافت ورودی تا زمانی که کاربر "exit" وارد کند**

```python
while True:
    user_input = input("یک عبارت وارد کنید (یا exit برای خروج): ")
    if user_input.lower() == "exit":
        break
    print(f"شما وارد کردید: {user_input}")
```

---

## **3. کنترل جریان حلقه‌ها (`break`, `continue`, `else`)**

### **الف) `break` — خروج زودهنگام از حلقه**

```python
for num in range(10):
    if num == 5:
        break  # حلقه در num=5 متوقف می‌شود
    print(num)
```

**خروجی:**

```
0
1
2
3
4
```

### **ب) `continue` — رد کردن یک تکرار**

```python
for num in range(10):
    if num % 2 == 0:
        continue  # اعداد زوج را رد می‌کند
    print(num)
```

**خروجی:**

```
1
3
5
7
9
```

### **ج) `else` — اجرای کد پس از اتمام حلقه**

```python
for num in range(3):
    print(num)
else:
    print("حلقه تمام شد!")
```

**خروجی:**

```
0
1
2
حلقه تمام شد!
```

---

## **4. توابع تکرارپذیر (`range`, `enumerate`, `zip`)**

### **الف) `range()` — تولید دنباله‌ای از اعداد**

```python
for i in range(5):       # 0 تا 4
    print(i)

for i in range(2, 6):    # 2 تا 5
    print(i)

for i in range(1, 10, 2): # 1 تا 9 با گام 2
    print(i)
```

### **ب) `enumerate()` — دریافت ایندکس و مقدار**

```python
fruits = ["سیب", "پرتقال", "موز"]
for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")
```

**خروجی:**

```
0: سیب
1: پرتقال
2: موز
```

### **ج) `zip()` — ترکیب دو لیست**

```python
names = ["علی", "رضا", "مریم"]
ages = [25, 30, 28]

for name, age in zip(names, ages):
    print(f"{name}: {age} سال")
```

**خروجی:**

```
علی: 25 سال
رضا: 30 سال
مریم: 28 سال
```

---

## **5. List Comprehension — تکرار فشرده برای ساخت لیست**

```python
# ساخت لیست مربع اعداد 0 تا 9
squares = [x**2 for x in range(10)]
print(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# فیلتر کردن اعداد فرد
odd_numbers = [x for x in range(10) if x % 2 != 0]
print(odd_numbers)  # [1, 3, 5, 7, 9]
```

---

## **6. توابع بازگشتی (Recursive Functions)**

تابعی که خودش را فراخوانی می‌کند.  
**مثال: محاسبه فاکتوریل**

```python
def factorial(n):
    return 1 if n == 1 else n * factorial(n - 1)

print(factorial(5))  # 120
```

---

## **نتیجه‌گیری**

| روش تکرار          | کاربرد                           |
| ------------------ | -------------------------------- |
| `for`              | تکرار روی عناصر یک دنباله        |
| `while`            | تکرار تا زمانی که شرط برقرار است |
| `break`            | خروج زودهنگام از حلقه            |
| `continue`         | رد کردن یک تکرار                 |
| `range()`          | تولید دنباله عددی                |
| `enumerate()`      | دریافت ایندکس و مقدار            |
| `zip()`            | ترکیب دو لیست                    |
| List Comprehension | ساخت لیست به صورت فشرده          |

# Decorator

کاربرد ات جا است که یک تابع داریم و می خواهیم کار قبلی را انحام دهد ولی یک دستور به ان اضافه شود

## دکوراتور چیست؟

- دکوراتور یک تابع است که یک تابع دیگر را به عنوان ورودی می‌گیرد و یک تابع جدید را بازمی‌گرداند.
- از دکوراتورها برای اضافه کردن قابلیت‌های جدید به توابع موجود استفاده می‌شود.
- با استفاده از @decorator_name قبل از تعریف تابع اعمال می‌شوند.

## دکوراتورهای استاندارد پایتون

برخی دکوراتورهای داخلی پایتون:

| دکوراتور      | کاربرد                    |
| ------------- | ------------------------- |
| @staticmethod | تعریف متد استاتیک در کلاس |
| @classmethod  | تعریف متد کلاس            |
| @property     | تعریف ویژگی‌های کلاس      |

## کاربردهای رایج دکوراتورها

1. لاگ کردن (ثبت اطلاعات اجرا)

2. اعتبارسنجی (مثلاً چک کردن ورودی‌ها)

3. کش کردن (ذخیره نتایج برای عملکرد بهتر)

4. تعیین سطح دسترسی (مثلاً چک کردن لاگین کاربر)

5. تایمر (اندازه‌گیری زمان اجرا)

## فرم کلی

```py
import functools

def Decorator(func):
@functools.warps(func)
def warpper_decorator(*Args, **kwargs):
    #do somthing before
    value = func(*Args, **kwargs):
    # do somthing after
    return value
return warpper_decorator
```

## مثال :

```py

def dec(func):
    def inner(x, y):
        if y == 0:
            return "warning!!!"
        return func(x, y)
    return inner

@dec
def f(x, y)
    return x/y

print(f(10, 12))
#برای انکه بتوانیم از تابع بالا هر جا که خواستیم استفاده کنیم باید در تعریف متغیر (قبل ) از * استافده کنیم
```

```py
def dec(func):
    def inner(*x, **y):
        if y == 0:
            return "warning!!!"
        return func(x, y)
    return inner

@dec
def f(x, y, z)
    return x/y+2

print(f(10, 12, 0))
```

## نکات مهم

- دکوراتورها می‌توانند تابع یا کلاس را تغییر دهند.

- ترتیب اعمال دکوراتورها مهم است (@A @B def f() معادل A(B(f)) است).

- برای حفظ متادیتاهای تابع اصلی (مثل **name**) از functools.wraps استفاده کنید.

مثال با functools.wraps:

```py
from functools import wraps

def debug(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"فراخوانی {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@debug
def say_hello():
    """این تابع سلام می‌کند"""
    print("سلام!")

print(say_hello.__name__)  # خروجی: say_hello (بدون wraps میشد wrapper)
print(say_hello.__doc__)   # خروجی: این تابع سلام می‌کند
```

## جمع‌بندی

| مفهوم               | مثال              | کاربرد                   |
| ------------------- | ----------------- | ------------------------ |
| دکوراتور ساده       | @decorator        | اضافه کردن قابلیت جدید   |
| دکوراتور با پارامتر | @decorator(arg)   | پیکربندی دکوراتور        |
| چند دکوراتور        | @A @B def f()     | ترکیب قابلیت‌ها          |
| @property           | @property def x() | کنترل دسترسی به ویژگی‌ها |

# ژنراتورها (Generators)

## 1. ژنراتور

- **تابع ویژه‌ای** که به جای `return` از `yield` استفاده می‌کند.
- **مقادیر را به صورت تنبل (Lazy Evaluation)** تولید می‌کند (یعنی فقط وقتی درخواست شود).
- **حافظه را بهینه می‌کند** (برای داده‌های حجیم ایده‌آل است).

---

## 2. ساخت ژنراتور

### تابع ژنراتور (با `yield`)

```python
def count_up_to(n):
    num = 1
    while num <= n:
        yield num  # مقدار را برمی‌گرداند و مکث می‌کند
        num += 1

# استفاده:
counter = count_up_to(5)
print(next(counter))  # 1
print(next(counter))  # 2
```

---

## 3. تفاوت ژنراتور با لیست معمولی

| ویژگی      | لیست                        | ژنراتور                  |
| ---------- | --------------------------- | ------------------------ |
| **حافظه**  | تمام مقادیر را ذخیره می‌کند | فقط یک مقدار در هر زمان  |
| **سرعت**   | سریع برای دسترسی تصادفی     | سریع برای پردازش ترتیبی  |
| **کاربرد** | داده‌های کوچک               | داده‌های حجیم یا بینهایت |

**مثال: تولید اعداد بینهایت**

```python
def infinite_numbers():
    num = 0
    while True:
        yield num
        num += 1

gen = infinite_numbers()
print(next(gen))  # 0
print(next(gen))  # 1
# ادامه دارد...
```

---

## 4. مثال

### الف) پردازش فایل‌های حجیم

```python
def read_large_file(file_path):
    with open(file_path, 'r') as file:
        for line in file:
            yield line.strip()

# استفاده بدون مصرف حافظه زیاد:
for line in read_large_file('data.txt'):
    print(line)
```

### ب) تولید دنباله‌های ریاضی

```python
def fibonacci(limit):
    a, b = 0, 1
    while a < limit:
        yield a
        a, b = b, a + b

print(list(fibonacci(50)))  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

### ج) خط لوله پردازش داده (Pipeline)

```python
def numbers():
    yield from range(10)

def squared(nums):
    for n in nums:
        yield n**2

def even(nums):
    for n in nums:
        if n % 2 == 0:
            yield n

# ترکیب ژنراتورها:
result = even(squared(numbers()))
print(list(result)))  # [0, 4, 16, 36, 64]
```

### ه) ژنراتور برای فیلتر کردن داده‌ها

```python
def filter_data(data, condition):
    for item in data:
        if condition(item):
            yield item

data = [10, 4, 7, 18, 2]
filtered = filter_data(data, lambda x: x > 5)
print(list(filtered)))  # [10, 7, 18]
```

### مثال های بیشتر

```py
def func(x):
    print("reza")
    yield x**2
    print("hello")
    yield 5
    print("ok")
    yield x-2

x = func(5)
next(x)
next(x)
next(x)

#output
#    reza
#    hello
#    ok
```

```py
def func(x):
    print("reza")
    yield x**2
    print("hello")
    yield 5
    print("ok")
    yield x-2

x = func(5)
    print(next(x))
    print(next(x))

#output
#    reza
#    25

#    hello
#    5
```

```py
def func():
    for i in range(1000):
        yield i**2

g = func()
print(next(g))
print(next(g))
.
.
.

```

```py
#جلوگیری از خطای استاب ایتریشن
def my_generator():
    print("welcome!")
    for i in range(5):
    yield i **2

g = my_generator()
iter_ = iter([1, 2, 3])

for i in g:
    print(i)
```

---

## 5. تفاوت `yield` و `return`

| ویژگی         | `yield`                         | `return`                |
| ------------- | ------------------------------- | ----------------------- |
| **حالت تابع** | تابع به حالت تعلیق درمی‌آید     | تابع خاتمه می‌یابد      |
| **مقادیر**    | چندین مقدار تولید می‌کند        | یک مقدار برمی‌گرداند    |
| **حافظه**     | مقادیر را یک به یک تولید می‌کند | همه را یکجا برمی‌گرداند |

---

## خلاصه

- **ژنراتور = تابع + `yield`**
- **بهینه برای داده‌های حجیم**
- **ترکیب‌پذیر با `for` و سایر ژنراتورها**
- **مصرف با `next()` یا حلقه‌ها**

# متت های لیست
در پایتون، لیست (List) یکی از ساختارهای داده‌ای پرکاربرد است که متدهای (methods) مختلفی برای مدیریت و دستکاری عناصر آن وجود دارد. در زیر مهم‌ترین متدهای لیست در پایتون را بررسی می‌کنیم:

### **۱. متدهای اضافه کردن عناصر**
- **`append(x)`**  
  یک عنصر `x` را به **انتهای** لیست اضافه می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.append(4)
  print(lst)  # خروجی: [1, 2, 3, 4]
  ```

- **`extend(iterable)`**  
  عناصر یک لیست یا شیء قابل پیمایش (iterable) را به انتهای لیست اضافه می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.extend([4, 5])
  print(lst)  # خروجی: [1, 2, 3, 4, 5]
  ```

- **`insert(i, x)`**  
  عنصر `x` را در **موقعیت `i`** درج می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.insert(1, 99)
  print(lst)  # خروجی: [1, 99, 2, 3]
  ```

### **۲. متدهای حذف عناصر**
- **`remove(x)`**  
  اولین عنصر با مقدار `x` را حذف می‌کند. اگر عنصر وجود نداشته باشد، `ValueError` می‌دهد.  
  مثال:
  ```python
  lst = [1, 2, 3, 2]
  lst.remove(2)
  print(lst)  # خروجی: [1, 3, 2]
  ```

- **`pop([i])`**  
  عنصر در **موقعیت `i`** را حذف و برمی‌گرداند. اگر `i` مشخص نشود، آخرین عنصر حذف می‌شود.  
  مثال:
  ```python
  lst = [1, 2, 3, 4]
  x = lst.pop(1)
  print(x)    # خروجی: 2
  print(lst)  # خروجی: [1, 3, 4]
  ```

- **`clear()`**  
  تمام عناصر لیست را حذف می‌کند و لیست خالی می‌شود.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.clear()
  print(lst)  # خروجی: []
  ```

### **۳. متدهای جستجو و اطلاعات**
- **`index(x[, start[, end]])`**  
  اولین ایندکس عنصر `x` را برمی‌گرداند. اگر وجود نداشته باشد، `ValueError` می‌دهد.  
  مثال:
  ```python
  lst = [10, 20, 30, 20]
  print(lst.index(20))       # خروجی: 1
  print(lst.index(20, 2))    # خروجی: 3 (جستجو از ایندکس 2)
  ```

- **`count(x)`**  
  تعداد تکرارهای عنصر `x` در لیست را برمی‌گرداند.  
  مثال:
  ```python
  lst = [1, 2, 2, 3, 2]
  print(lst.count(2))  # خروجی: 3
  ```

### **۴. متدهای مرتب‌سازی و تغییر ترتیب**
- **`sort(key=None, reverse=False)`**  
  لیست را **به‌صورت درجا** (in-place) مرتب می‌کند.  
  مثال:
  ```python
  lst = [3, 1, 4, 2]
  lst.sort()
  print(lst)  # خروجی: [1, 2, 3, 4]
  ```

- **`reverse()`**  
  ترتیب عناصر لیست را معکوس می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.reverse()
  print(lst)  # خروجی: [3, 2, 1]
  ```

  ### تفاوت `reverse()` و `reversed()`:
  - **`list.reverse()`**:  
    - یک **متد لیست** است و لیست را **درجا (in-place)** معکوس می‌کند (یعنی لیست اصلی تغییر می‌کند).  
    - مقدار بازگشتی ندارد (`None` برمی‌گرداند).  
    مثال:
    ```python
    lst = [1, 2, 3]
    lst.reverse()
    print(lst)  # خروجی: [3, 2, 1] (لیست اصلی تغییر کرد)
    ```

  - **`reversed(list)`**:  
    - یک **تابع built-in** است و لیست اصلی را تغییر **نمی‌دهد**.  
    - یک **iterator** برمی‌گرداند که عناصر را به صورت معکوس می‌دهد.  
    - برای تبدیل به لیست، باید از `list()` استفاده کرد.  
    مثال:
    ```python
    lst = [1, 2, 3]
    reversed_lst = reversed(lst)  # یک iterator برمی‌گرداند
    print(list(reversed_lst))     # خروجی: [3, 2, 1]
    print(lst)                   # خروجی: [1, 2, 3] (لیست اصلی تغییر نکرده)
    ```

  ### کاربرد `reversed()`:
  - وقتی می‌خواهید لیست را معکوس کنید **بدون تغییر لیست اصلی**.  
  - مناسب برای حلقه‌های معکوس:
    ```python
    for item in reversed([1, 2, 3]):
        print(item)  # چاپ: 3, 2, 1
    ```

  ### مثال‌های بیشتر:
  ```python
  # معکوس کردن یک رشته
  s = "hello"
  print(list(reversed(s)))  # ['o', 'l', 'l', 'e', 'h']
  print(''.join(reversed(s)))  # 'olleh'

  # معکوس کردن تاپل
  t = (1, 2, 3)
  print(tuple(reversed(t)))  # (3, 2, 1)
  ```

### **۵. متدهای کپی و ایجاد لیست جدید**
- **`copy()`**  
  یک **کپی سطحی** (shallow copy) از لیست ایجاد می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst2 = lst.copy()
  print(lst2)  # خروجی: [1, 2, 3]
  ```

### **۶. سایر متدهای مفید**
- **`len(list)`** (تابع built-in)  
  تعداد عناصر لیست را برمی‌گرداند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  print(len(lst))  # خروجی: 3
  ```

- **`max(list)` و `min(list)`** (توابع built-in)  
  بزرگترین و کوچکترین عنصر لیست را برمی‌گردانند.  
  مثال:
  ```python
  lst = [5, 2, 8, 1]
  print(max(lst))  # خروجی: 8
  print(min(lst))  # خروجی: 1
  ```

### **جمع‌بندی**
| متد | توضیح |
|------|------|
| `append(x)` | اضافه کردن `x` به انتهای لیست |
| `extend(iterable)` | اضافه کردن چند عنصر به لیست |
| `insert(i, x)` | درج `x` در موقعیت `i` |
| `remove(x)` | حذف اولین عنصر با مقدار `x` |
| `pop([i])` | حذف و برگرداندن عنصر در موقعیت `i` |
| `clear()` | خالی کردن لیست |
| `index(x)` | یافتن ایندکس اولین وقوع `x` |
| `count(x)` | شمارش تعداد تکرار `x` |
| `sort()` | مرتب‌سازی لیست |
| `reverse()` | معکوس کردن ترتیب لیست |
| `copy()` | ایجاد کپی از لیست |

# متد های تاپل و مجموعه ها
---

##  **متدهای تاپل (Tuple Methods)**  
تاپل‌ها **Immutable** هستند، بنابراین متدهای تغییردهنده (مانند `append()` یا `remove()`) را ندارند.

### ۱- **`count(x)`**  
تعداد تکرارهای عنصر `x` در تاپل را برمی‌گرداند.  
```python
t = (1, 2, 2, 3, 2)
print(t.count(2))  # خروجی: 3
```

### ۲- **`index(x)`**  
اولین ایندکس عنصر `x` را برمی‌گرداند. اگر وجود نداشته باشد، `ValueError` می‌دهد.  
```python
t = (10, 20, 30, 20)
print(t.index(20))  # خروجی: 1
```

###  **نکته مهم:**  
- تاپل‌ها متدهای `append()`، `remove()`، `sort()` و ... **ندارند** چون غیرقابل تغییر هستند.  
- اگر نیاز به تغییر دارید، باید تاپل را به لیست تبدیل کنید و دوباره تاپل بسازید:
  ```python
  t = (1, 2, 3)
  lst = list(t)
  lst.append(4)
  t = tuple(lst)
  print(t)  # خروجی: (1, 2, 3, 4)
  ```

---

##  **متدهای مجموعه (Set Methods)**  
مجموعه‌ها (**Set**) **ترتیب ندارند** و **عناصر تکراری** را ذخیره نمی‌کنند. متدهای اصلی آنها:

### ۱- **اضافه و حذف عناصر**  
| متد | توضیح |
|------|-------|
| `add(x)` | اضافه کردن `x` به مجموعه |
| `remove(x)` | حذف `x` از مجموعه (اگر نباشد `KeyError` می‌دهد) |
| `discard(x)` | حذف `x` از مجموعه (اگر نباشد خطا نمی‌دهد) |
| `pop()` | یک عنصر **تصادفی** حذف و برمی‌گرداند |
| `clear()` | پاک کردن تمام مجموعه |

مثال:
```python
s = {1, 2, 3}
s.add(4)       # {1, 2, 3, 4}
s.remove(2)    # {1, 3, 4}
s.discard(99)  # خطا نمی‌دهد
print(s.pop()) # یک عنصر تصادفی برمی‌گرداند
```

### ۲- **عملیات مجموعه‌ها**  
| متد | توضیح |
|------|-------|
| `union(other_set)` | اجتماع دو مجموعه (`|`) |
| `intersection(other_set)` | اشتراک دو مجموعه (`&`) |
| `difference(other_set)` | تفاوت دو مجموعه (`-`) |
| `symmetric_difference(other_set)` | تفاضل متقارن (`^`) |
| `update(other_set)` | اضافه کردن همه عناصر `other_set` به مجموعه فعلی |

مثال:
```python
A = {1, 2, 3}
B = {3, 4, 5}
print(A.union(B))            # {1, 2, 3, 4, 5}
print(A.intersection(B))     # {3}
print(A.difference(B))       # {1, 2}
print(A.symmetric_difference(B))  # {1, 2, 4, 5}
```

### ۳- **متدهای بررسی**  
| متد | توضیح |
|------|-------|
| `issubset(other_set)` | آیا مجموعه زیرمجموعه `other_set` است؟ |
| `issuperset(other_set)` | آیا مجموعه ابرمجموعه `other_set` است؟ |
| `isdisjoint(other_set)` | آیا دو مجموعه اشتراکی ندارند؟ |

مثال:
```python
A = {1, 2}
B = {1, 2, 3}
print(A.issubset(B))    # True
print(B.issuperset(A))  # True
print(A.isdisjoint({4, 5}))  # True
```


#### **4- متد `difference()`**  
تفاوت دو مجموعه را برمی‌گرداند (عناصری که در مجموعه اول هستند ولی در مجموعه دوم نیستند).  
✅ **تغییری در مجموعه اصلی ایجاد نمی‌کند.**  
```python
s = {1, 2, 3, 4}
x = {3, 4, 5, 6}
print(s.difference(x))  # خروجی: {1, 2}
print(s)  # خروجی: {1, 2, 3, 4} (مجموعه اصلی تغییر نکرده)
```

#### **5- متد `difference_update()`**  
تفاوت دو مجموعه را محاسبه کرده و **تغییرات را روی مجموعه اصلی اعمال می‌کند.**  
❌ **مجموعه اصلی را تغییر می‌دهد و مقدار بازگشتی ندارد (`None`).**  
```python
s = {1, 2, 3, 4}
x = {3, 4, 5, 6}
s.difference_update(x)  # اعمال تغییرات روی s
print(s)  # خروجی: {1, 2} (مجموعه اصلی تغییر کرد)
```

#### **6- متد `isdisjoint()`**  
اگر دو مجموعه **هیچ عنصر مشترکی نداشته باشند**، `True` برمی‌گرداند.  
```python
s = {1, 2, 3, 4}
x = {5, 6, 7}
print(s.isdisjoint(x))  # خروجی: True (چون اشتراکی ندارند)

y = {3, 4, 5}
print(s.isdisjoint(y))  # خروجی: False (چون ۳ و ۴ مشترک هستند)
```

---

### **جمع‌بندی متدهای مجموعه (Set)**
| متد | توضیح | تغییر در مجموعه اصلی؟ |
|------|-------|------------------|
| `difference()` | تفاوت دو مجموعه را برمی‌گرداند | ❌ |
| `difference_update()` | تفاوت را روی مجموعه اصلی اعمال می‌کند | ✅ |
| `isdisjoint()` | بررسی عدم اشتراک دو مجموعه | ❌ |


---


### **جمع‌بندی:**
| نوع | مهم‌ترین متدها |
|------|---------------|
| **تاپل** | `count()`, `index()` |
| **مجموعه** | `add()`, `remove()`, `union()`, `intersection()`, `difference()` |

