# **_vscode_**

- [**_vscode_**](#vscode)
- [عمل گر مقایسه ای](#عمل-گر-مقایسه-ای)
- [عملگرهای انتساب](#عملگرهای-انتساب)
- [عملگرهای منطقی](#عملگرهای-منطقی)
- [**split**](#split)
- [join](#join)
- [کاراکتر بک‌اسلش (\\)](#کاراکتر-بکاسلش-)

- [**تکه بندی**](#تکه-بندی)
    - [(f-string)فرمت دهی رشته با](#f-stringفرمت-دهی-رشته-با)

- [**لیست**](#لیست)
    - [ویژگی‌های کلیدی:](#ویژگیهای-کلیدی)
    - [دستورات پرکاربرد](#دستورات-پرکاربرد)

- [**دیکشنری**](#دیکشنری)
  - [تعریف دیکشنری](#تعریف-دیکشنری)
  - [ویژگی‌های کلیدی:](#ویژگیهای-کلیدی-1)
  - [روش‌های ایجاد دیکشنری:](#روشهای-ایجاد-دیکشنری)
  - [متدهای مهم:](#متدهای-مهم)
  - [مثال پیشرفته:](#مثال-پیشرفته)

- [**حلقه**](#حلقه)
  - [**انواع حلقه‌ها :**](#انواع-حلقهها-)
    - [1. حلقه `for`](#1-حلقه-for-برای-تکرار-روی-دنبالهها)
    - [2. حلقه `while`](#2-حلقه-while-برای-تکرار-شرطی)
  - [**کنترل جریان حلقه‌ها**](#کنترل-جریان-حلقهها)
    - [1. `break` (خروج از حلقه)](#1-break-خروج-از-حلقه)
    - [2. `continue` (رد کردن یک تکرار)](#2-continue-رد-کردن-یک-تکرار)
    - [3. `else` (پس از اتمام حلقه)](#3-else-پس-از-اتمام-حلقه)
    - [4. enumerate](#4-enumerate)
  - [تکنیک‌های پیشرفته](#تکنیکهای-پیشرفته)
  
  - [نکات مهم:](#نکات-مهم)
  - [مثال کاربردی:](#مثال-کاربردی)

- [zip](#zip)

- [**تابع**](#تابع)
    - [تعریف تابع](#1-برای-تعریف-تابع-از-کلمه-کلیدی-def-استفاده-میشود)
    - [انواع پارامترها](#2انواع-پارامترها)
    - [return](#3-return)
    - [توابع بازگشتی (Recursive)](#4-توابع-بازگشتی-recursive)
    - [توابع لامبدا (Lambda)](#5-توابع-لامبدا-lambda)
    - [دکوراتورها (Decorators)](#6-دکوراتورها-decorators)
    - [مثال](#مثال)
    - [نکات مهم:](#نکات-مهم-1)

- [**یادداشت تابع (function annotation)**](#یادداشت-تابع-function-annotation)
  - [مثال](#مثال-1)

- [**توابع لامبدا**](#توابع-لامبدا)
  - [1. ساختار توابع لامدا:](#1-ساختار-توابع-لامدا)
  - [2. دستورات لامدا](#2-دستورات-لامدا)
    - [1. تابع map:](#1-تابع-map)
    - [2. تابع filter:](#2-تابع-filter)
    - [3. تابع reduce:](#3-تابع-reduce)
    - [4. تابع sorted:](#4-تابع-sorted)
- [pass](#pass)
- [DocString](#docstring)

- [**تکرار (Iteration)**](#تکرار-iteration)
  - [1. حلقه `for` ](#1-حلقه-for--تکرار-بر-روی-عناصر-یک-دنباله)
  - [2. حلقه `while`](#2-حلقه-while--تکرار-تا-زمانی-که-شرط-برقرار-است)
  - [3. کنترل جریان حلقه‌ها (`break`, `continue`, `else`)](#3-کنترل-جریان-حلقهها-break-continue-else)
  - [4. توابع تکرارپذیر (`range`, `enumerate`, `zip`)](#4-توابع-تکرارپذیر-range-enumerate-zip)
  - [نتیجه‌گیری](#نتیجهگیری)

- [**Decorator**](#decorator)
  - [دکوراتورهای استاندارد پایتون](#دکوراتورهای-استاندارد-پایتون)
  - [کاربردهای رایج دکوراتورها](#کاربردهای-رایج-دکوراتورها)
  - [فرم کلی](#فرم-کلی)
  - [مثال :](#مثال-)
  - [نکات مهم](#نکات-مهم-2)
  - [جمع‌بندی](#جمعبندی)

- [**ژنراتورها (Generators)**](#ژنراتورها-generators)
  - [1. ژنراتور](#1-ژنراتور)
  - [2. ساخت ژنراتور](#2-ساخت-ژنراتور)
    - [تابع ژنراتور (با `yield`)](#تابع-ژنراتور-با-yield)
  - [3. تفاوت ژنراتور با لیست معمولی](#3-تفاوت-ژنراتور-با-لیست-معمولی)
  - [4. مثال](#4-مثال)
    - [مثال های بیشتر](#مثال-های-بیشتر)
  - [5. تفاوت `yield` و `return`](#5-تفاوت-yield-و-return)
  - [خلاصه](#خلاصه)

- [**متد لیست**](#متت-های-لیست)
  -  [متدهای اضافه کردن عناصر](#۱-متدهای-اضافه-کردن-عناصر)
  -  [متد حذف عتاصر](#۲-متدهای-حذف-عناصر)
  -  [متد جست و جو](#۳-متدهای-جستجو-و-اطلاعات)
  -  [متد مرتب سازی](#۴-متدهای-مرتبسازی-و-تغییر-ترتیب)
  -  [متد کپی و ایجاد لیست جدید](#۵-متدهای-کپی-و-ایجاد-لیست-جدید)
  -  [سایر متد ها](#۶-سایر-متدهای-مفید)
  -  [جمع بندی](#جمع-بندی)

- [**متد های تاپل و مجموعه ها**](#متد-های-تاپل-و-مجموعه-ها)
  - [متد تاپل ها](#متدهای-تاپل-tuple-methods)
  - [متد مجموعه ها](#متدهای-مجموعه-set-methods)

- [**متد های دیکشنری**](#متد-های-دیکشنری)
  - [متد های اصلی دیکشنری](#متدهای-اصلی-دیکشنری)
  - [متدهای بررسی و کاربردهای پیشرفته](#متدهای-بررسی-و-کاربردهای-پیشرفته)
  - [تفاوت `copy()` و `deepcopy()`](#تفاوت-copy-و-deepcopy)
  - [جمع‌بندی ](#-جمعبندی-متدهای-دیکشنری)

- [**متد رشته**](#متد-رشته)
  - [تبدیل حروف و نرمال‌سازی](#1-تبدیل-حروف-و-نرمالسازی)
  - [جستجو و بررسی محتوا](#2-جستجو-و-بررسی-محتوا)
  - [اصلاح و فرمت‌دهی متن](#3-اصلاح-و-فرمتدهی-متن)

- [**عملگر والروس**](#عملگر-والروس)
  - [کاربرد ها](#کاربرد-اصلی)
  - [مثال‌های کاربردی](#مثالهای-کاربردی)
  - [محدودیت‌ها و نکات مهم](#محدودیتها-و-نکات-مهم)
  
- [**تابع open( )**](#تابع-open)
  - [پارامترهای تابع](#پارامترهای-تابع-open)
    - [file](#1-پارامتر-file)
    - [mode](#2-پارامتر-mode)
    - [buffering](#3-پارامتر-buffering)
    - [encoding](#4-پارامتر-encoding)
    - [errors](#5-پارامتر-errors)
    - [newline](#6-پارامتر-newline)
    - [closefd](#7-پارامتر-closefd)
    - [opener](#8-پارامتر-opener)
  - [روش‌های کار با فایل باز شده](#روشهای-کار-با-فایل-باز-شده)
  - [مثال‌](#مثالهای-تابع-open)
  - [نکات مهم](#نکات-مهم-و-بهترین-روشها)

- [**متد خواند و نوشتن در فایل**](#متدهای-خواندن-و-نوشتن)
  - [متد خواند ](#۱-متدهای-خواندن-فایل) 
  - [متد readable( )](#متد-readable)
  - [متد نوشتن](#2-متدهای-اصلی-نوشتن) 
  - [مدیریت بافر](#3-مدیریت-بافر) 
  - [متد writable( )](#متد-writable) 
  - [نوشتن کردن فایل باینیری/غیراسکی ](#33-نوشتن-کردن-فایل-باینیریغیراسکی) 

- [**تغیر موقعیت اشاره گر**](#تغیر-موقعیت-اشاره-گر) 

- [**دستور `with/as` و مدیریت زمینه (Context Manager)**](#دستور-withas-و-مدیریت-زمینه-context-manager)
  - [ساختار](#ساختار-پایه)
  - [مزایای استفاده ](#مزایای-استفاده-از-with)
  - [نحوه کار Context Manager](#نحوه-کار-context-manager)
  
- [**json**](#کار-با-فایل-جیسون---json)
  - [تبدیل جیسون به پایتون](#تبدیل-جیسون-به-پایتون)
  - [تبدیل پایتون به جیسون](#تبدیل-پایتون-به-جیسون)
  - [**دندانه گذاری**](#دندانه-گذاری)
    - [indent](#1-indent)
    - [sort_keys](#2-sort_keys)
    - [separators](#3-separators)
- [**csv**](#کار-با-فایل---csv)
  - [**خواندن از فایل‌های CSV**](#1خواندن-از-فایلهای-csv)
    - [reader](#الف-csvreader)
    - [DictReader](#ب-csvdictreader)
  - [**نوشتن در فایل‌های CSV**](#2-نوشتن-در-فایلهای-csv)
    - [writerow( )](#الف--writerow-)
    - [writerows( )](#ب-writerows-)
  - [تفاوت writerow( ) و writerows( )](#تفاوت-writerow--و-writerows--)
- [**شی گرای**](#شی-گرای)
    - [ایجاد کلاس](#ایجاد-کلاس)
    - [ایجاد شیء](#ایجاد-شیء)
    - [اضافه کردن اتریبیوت](#اضافه-کردن-اتریبیوت)
    - [اضافه کردن متد ](#اضافه-کردن-متد)
    - [**فراخوانی متدها**](#فراخوانی-متدها)
      - [فراخوانی متد عادی ](#1-فراخوانی-متد-عادی-instance-method)
      - [فراخوانی متد کلاس ](#2-فراخوانی-متد-کلاس-class-method)
    - [مثال تکمیلی](#مثال-تکمیلی)
  - [مقدار دهی اولیه شی](#مقدار-دهی-اولیه-شی)
  - [**مستند سازی کلاس**](#مستند-سازی-کلاس-و-ابزار-doctest-و-mypy)
    - [مشاهده Decorator](#مشاهده-decorator)
    - [doctest](#doctest)
    - [mypy](#mypy)
- [**(در شی گرای)ماژول‌ها و کلاس‌ها**](#در-شی-گرایماژولها-و-کلاسها)
  - [مشکل ساخت آبجکت زمان‌بر در زمان ایمپورت و راه‌حل آن](#مشکل-ساخت-آبجکت-زمانبر-در-زمان-ایمپورت-و-راهحل-آن)
  - [(Type Hinting / Annotations)](#type-hinting--annotations)
- [**سطح دسترسی و کاربرد های underscore**](#سطح-دسترسی-و-کاربرد-های-underscore)
  - [1. استفاده از یک آندرسکور ](#1-استفاده-از-یک-آندرسکور-به-تنهایی-_)
  - [2. استفاده از یک آندرسکور قبل از اسم](#2-استفاده-از-یک-آندرسکور-قبل-از-اسم-_variable-یا-_method)
  - [3. استفاده از یک آندرسکور بعد از اسم](#3-استفاده-از-یک-آندرسکور-بعد-از-اسم-variable_)
- []()
- []()
- []()
- []()
- []()
- []()
- []()
- []()


# عمل گر مقایسه ای

- == : equal
- != : not equal
- .> : greatel than //همان
- < : less than
- .>= : greater than or equal to //کوچیک تر مساوی
- <= : less than or equal to

# عملگرهای انتساب

- += x=x+2
- -= x=x-2
- *= x=x*2
- /= x=x/2
- %= x=x%2 //باقی مانده
- //= x=x//2
- **= x=x**2 //توان 2

```
    x = 4
    x += 2;
    print(x);       //پرینت می کنه 6
```

# عملگرهای منطقی

![alt text](<picture-lening/عملگرهای منطقی.png>)

- ما می توان با دستور + دو تا رشته را به هم جمع کنیم

  > print("x"+"y")

- دستور را چندین بار تکرار میکند

  > print(4\*"alireza")

- اخرین رقم ان عدد را نشان می دهد
  print(هر عددی %10)

- به میزانی که عدد گذاشتیم عدد را رند می کند

  > print(round(motegaier, 2))

- متوجه میشیم که یک متغیر جزو کدام نوع داده هست

  > print(isinstance(نوع متغیر , متغیر))

- تعداد تکرار را میشمرد

  > [رشته].count()

- فضای خالی از سمت راست را پاک می کند

  > [رشته].rstrip

- پیدا می کند از داخل رشته

  > [رشته].find

- یک کارکتر چند بار تکرار شده

  > تابع.count('یک کارکتر از تابع')

- برسی می کند که یک تابع با یک کارکتر خاص به اتمام رسیده است یا خیر

  > تابع. endswith("کارکتر")

- برسی می کند که یک تابع با یک کارکتر خاص شروع شده یا خیر

  > تابع. startswith("کارکتر")

- کارکتر را پیدا میکند
- ایندکس ان (از سمت چپ شروع می شود)

  > تابع . find ('کارکتر')

- نشان میده که کل کارکتر فقط عدد است یا نه

  > تابع . isnumeric()

- > تابع . replace ('کارکتر که می خوایم عوض بشه ', 'کارکتری که جایگذاری بشه')

- اگر داخل پرانتز خالی باشد فاصله در نظر می گیرد ; فاصله های اضاقی از ابتدا و انتهای را پاک می کند

  > تابع . strip()

- از سمت چپ فقط پاک میکند

  > تابع . lreplace

- مقدار تکرار یک چیز را می شمارد

  > c . count(تابع)

- یونیکد

  > ord()

- مقادیر را مرتب می کند

  > sorted()

- نوع رشته را مشخص میکند
  > (type(رشته))

# **split**

- این دستور ترکیبی از دو عمل اصلی است که برای دریافت ورودی از کاربر و تقسیم آن به بخش‌های جداگانه استفاده می‌شود:

- .split()

  - متدی برای رشته‌ها که آنها را بر اساس جداکننده (پیش‌فرض: فاصله) تقسیم می‌کند

  - نتیجه یک لیست از زیررشته‌ها است

  ```py
  data = input("enter: ").split(',')
   ورودی: "علی,رضا,مریم"
   → ['علی', 'رضا', 'مریم']
  ```

# join

- دو تابع را به یک دیگر متصل می کند

```py
s = "*"
l + ["a" , "b" , "c"]
print(s.join(l))
===> a*b*c
```

# کاراکتر بک‌اسلش (\\)

- (\دستور) ----- کار این دستور لغو کردن دستورات است

- \n ------ می رود خط بعدی
- \\\ ----- c:\alireza\new ==> c:\alireza\\\new
- \t ------- یک تب فاصله می دهد
- اگر قبل رشته دستور (r')بزنیم تمام دستورات \ را لغو می کند
- \b ------ حرف قبلی را پاک می کند

# تکه بندی

- برای اینکه بتوانیم ایندکس یک رشته را بگیریم

  - (s[ایندکس])

- برای چاپ کردن یک بخشی از رشته

  - (رشته[ایندکس: ایندکس])
  - اگر در هر قسمت ایندکس نگذاریم تا اخر رشته را استفاده می کند

- طول گام را مشخص می کند

  - ([گام: ایندکس :ایندکس]رشته)

- (len(رشته)) سایز رشته را نشان می دهد

- (رشته[::]) رشته را معکوس می کند

### (f-string)فرمت دهی رشته با

```py
name = "alireza"
age = 18

msg =(
f"name: {name}\n"
f'age: {age}\n
     )

print(msg)

autput= name: alireza
       age:18
```

# لیست

لیست یک ساختار داده‌ی تغییرپذیر و ترتیبی در پایتون است که می‌تواند عناصر مختلف را ذخیره کند .

> my_list = [1, "دو", 3.0, True] # ایجاد لیست با انواع داده مختلف

### ویژگی‌های کلیدی:

1. تغییرپذیر (Mutable): محتوا قابل تغییر است
   > my_list[0] = 10 # تغییر اولین عنصر
2. ترتیبی (Ordered): ترتیب عناصر حفظ می‌شود
3. پشتیبانی از انواع داده مختلف:
   > mixed = [1, "text", 3.14, [1, 2]] # لیست در لیست

- `متدهای پرکاربرد`

```
1.  print(my_list[0])  # اولین عنصر (ایندکس 0)
2.  print(my_list[-1]) # آخرین عنصر
3. print(my_list[1:3])  # عناصر از ایندکس 1 تا 2
4. my_list.append(4)       # اضافه کردن به انتها
5. my_list.insert(1, 1.5)  # درج در موقعیت خاص
6. my_list.remove("دو")    # حذف مقدار خاص
7. popped = my_list.pop()  # حذف و بازگرداندن آخرین عنصر
8. len(my_list)      # طول لیست
9. my_list.sort()    # مرتب‌سازی
10. my_list.reverse() # معکوس کردن ترتیب
```

- `نکته`
  - با گذاشتن ستاره قبل از یک کارکتر کارکتر را تبدیل به لیست میکند

```py
a, b, *c = [1, 2, 3, 4, 5, 6]
print(a, b, c)

autput = 1      2       [3, 4, 5, 6]
```

### دستورات پرکاربرد

1. **reversed** = یکی از لیست ها را معکوس می کند

```python
x = ['Alice', 'Bob', 'Charlie']
y = [25, 30, 35]
for i, j in reversed(x,y):
   print(i)
```

2. **sorted**
   (به ترتیب حرف الف با)تمامی لیست را مرتب می کند

```python
x = ['Alice', 'Bob', 'Charlie']
y = [25, 30, 35]
for i, j in sorted(x):
    print(i)
```

3. **random**
   min + (random \* (max - min)) عدد رندوم در بازه ای که میخوایم تولید می کند

- random.uniform یک تابع از ماژول random است که برای تولید اعداد تصادفی با توزیع یکنواخت پیوسته (Continuous Uniform Distribution) استفاده می‌شود. این تابع یک عدد اعشاری تصادفی در بازه مشخص شده ([a, b]) برمی‌گرداند که همه مقادیر در این بازه احتمال یکسانی دارند.

- تفاوت random.uniform با random.random:

  - random.random() فقط اعداد بین ۰.۰ تا ۱.۰ تولید می‌کند.

  - random.uniform(a, b) اعداد بین a تا b (شامل a و b) تولید می‌کند.

```python
import random

# با random.random
rand1 = random.random()  # مثلاً 0.74321

# با random.uniform
rand2 = random.uniform(5, 10)  # مثلاً 7.8321
```

```python
#مثال
#(تولید عدد رندوم در بازه بیت 5 تا 10 )
from random import random
for _ in range(10):
    print(5 + (random() * (10 - 5)))

#مثال 2
from random import random
for _ in range(10):
    print(5 + (random() * (10)))

#random uniform

from random import random, uniform
for _ in range(10):
    print(uniform(5,10))

#تولید عدد رندوم intger

from random import randint
for _ in range(10):
    print(randint(5, 16))

#تولید عدد رندوم با طول گام

from random import randrange
for _ in range(10):
    print(randrange(5, 50, 3))


#از بازه موجود به صورت رندوم یک را انتخاب می کند
from random import choice
x = ["a", "b", "c","d"]
for _ in range(10):
    print(choice(x))

#یک زیر لیست از لیست درست می کند

from random import sample
x = ["a", "b", "c","d"]
print(sample(x, 2))
print(x)
```

`نکته:`
اگر می خواهیم بعد از تولید یک زیر لیست , زیر لیست تغیر نکند از دستور
(**seed**) استقاده می کنیم

```python
from random import sample, seed
x = ["a", "b", "c","d"]
seed(10)
print(sample(x, 2))
print(x)
```

4.  **shuffle**
    بور می زند یعنی لبست من را شانسی بور می زند

```python
from random import shuffle
x = ["a", "b", "c","d"]
shuffle(x)
print(x)
```

# دیکشنری

## تعریف دیکشنری

- دیکشنری (Dictionary) یک ساختار داده‌ی **تغییرپذیر**، **نامرتب** و **ایندکس‌گذاری شده با کلید** در پایتون است که داده‌ها را به صورت جفت‌های `کلید: مقدار` ذخیره می‌کند.

```python
my_dict = {"name": "علی", "age": 25, "city": "تهران"}
```

## ویژگی‌های کلیدی:

1. **تغییرپذیر (Mutable)**: مقادیر قابل تغییر هستند
2. **نامرتب (Unordered)**: ترتیب عناصر حفظ نمی‌شود (تا پایتون 3.6)
3. **عدم اجازه کلید تکراری**: هر کلید فقط یک بار می‌تواند وجود داشته باشد

## روش‌های ایجاد دیکشنری:

1. روش مستقیم:

   ```python
   person = {"name": "رضا", "age": 30}
   ```

2. استفاده از تابع `dict()`:

   ```python
   person = dict(name="نازنین", age=28)
   ```

3. از لیست تاپل‌ها:
   ```python
   pairs = [("one", 1), ("two", 2)]
   numbers = dict(pairs)
   ```

## متدهای مهم:

- اگر بخواهیم یک متغیر تعریف کنیم که هیچ متغیر خاصی ندارد از \***\*none type\*\*** استفاده می کنیم
  تابع = none

```python
keys = person.keys()    # لیست کلیدها
values = person.values()  # لیست مقادیر
items = person.items()   # لیست جفت‌های کلید-مقدار
```

## مثال پیشرفته:

```python
students = {
    1001: {"name": "علی", "grades": [18, 20, 16]},
    1002: {"name": "زهرا", "grades": [19, 17, 20]}
}

# محاسبه میانگین نمرات
for student_id, info in students.items():
    avg = sum(info["grades"]) / len(info["grades"])
    print(f"{info['name']}: {avg:.2f}")
```

# حلقه

## انواع حلقه‌ها :

### 1. حلقه `for` (برای تکرار روی دنباله‌ها)

```python
for item in sequence:
    # دستورات
```

مثال:

```python
fruits = ["سیب", "پرتقال", "موز"]
for fruit in fruits:
    print(fruit)
```

### 2. حلقه `while` (برای تکرار شرطی)

```python
while condition:
    # دستورات
```

مثال:

```python
count = 0
while count < 5:
    print(count)
    count += 1
```

مثال 2:

```
n = int(input("x = "))
while n < 100:
    if n % 2 == 0 :
     print(n)
n += 1
اعداد زوج را چاپ می کند
```

## کنترل جریان حلقه‌ها

### 1. `break` (خروج از حلقه)

```python
for num in range(10):
    if num == 5:
        break
    print(num)
```

```python
n = float(input("n:"))
m = n
while True:
    s = input("do tou cantinue?")
    if s.lower() == "no":
        break
    n = float(input("n:"))
    if n < m :
        m = n
        print(m,"min:")
```

### 2. `continue` (رد کردن یک تکرار)

```python
for num in range(10):
    if num % 2 == 0:
        continue
    print(num)  # فقط اعداد فرد
```

### 3. `else` (پس از اتمام حلقه)

```python
for num in range(3):
    print(num)
else:
    print("حلقه کامل اجرا شد")
```

```python
i = 0
while i <10:
   i += 1
   if i % 3 == 0:
       break
    print(i)
else:
    print("ok")
autput
1
2
```

```python
n = int(input("n:"))
i = 2
if n > 1:
    while i < n:
        if n % i == 0:
            print(n,"is nat prime number")
            break
        i += 1
    else:
        print(n, "not prime number")
else:
    print(n,"is a not prime number")
#برسی می کند عدد اول هست یا نه
```

### 4. enumerate

تابع **enumerate** در پایتون به شما اجازه می‌دهد تا همزمان به اندیس و مقدار عناصر یک لیست دسترسی داشته باشید.

```python
  l = ["a", "b", "c", "d"]
  for i ,j enumerate(l):
     print(i, ":", j)

  autput
  0 : a
  1 : b
  3 : c
  4 : d
```

## تکنیک‌های پیشرفته

### 1. حلقه با `range()`

اگر بخواهیم در حلقه (for )یک رنج تعریف کنیم از دستور **range**استفاده می کنیم

- range(طول گام , بازه )

```python
for i in range(5):       # 0 تا 4
for i in range(2, 6):    # 2 تا 5
for i in range(1, 10, 2): # 1 تا 9 با گام 2
```

مثال :

```python
   l = input("name:").split("-")
   print(l)
   for i in range(0, len(l)):
     print(i, L[i])
```

### 2. حلقه روی دیکشنری

```python
person = {"name": "علی", "age": 30}

for key in person:         # کلیدها
for value in person.values(): # مقادیر
for key, value in person.items(): # جفت‌ها
```

### 3. حلقه‌های تو در تو

```python
for i in range(3):
    for j in range(2):
        print(f"({i}, {j})")
```

### 4. فهرست‌سازی (List Comprehension)

```python
squares = [x**2 for x in range(10)]
```

## نکات مهم:

- از حلقه `for` برای تکرار روی اشیاء قابل پیمایش استفاده کنید
- از حلقه `while` وقتی تعداد تکرارها نامشخص است استفاده کنید
- از `break` و `continue` برای کنترل جریان استفاده کنید
- `range()` یک دنباله اعداد ایجاد می‌کند

## مثال کاربردی:

```python
# محاسبه فاکتوریل
n = 5
factorial = 1
for i in range(1, n+1):
    factorial *= i
print(f"!{n} = {factorial}")
```

# zip

دستور zip در پایتون دو یا چند لیست را گرفته و آن‌ها را به صورت زوج‌های (tuple) ترکیب می‌کند.

```python
x = ['Alice', 'Bob', 'Charlie']
y = [25, 30, 35]
for i, j in zip(x,y):
   print("name", i, "age", j)
```

# تابع

تابع (Function) در پایتون یک بلوک کد قابل استفاده مجدد است که یک کار خاص را انجام می‌دهد. توابع به سازماندهی کد، جلوگیری از تکرار و افزایش خوانایی کمک می‌کنند.

### 1. برای تعریف تابع از کلمه کلیدی `def` استفاده می‌شود:

```python
def نام_تابع(پارامترها):
    # بدنه تابع
    return نتیجه  # اختیاری
```

---

### **2.انواع پارامترها**

#### **الف) پارامترهای معمولی**

```python
def add(a, b):
    return a + b

print(add(3, 5))  # خروجی: 8
```

#### **ب) پارامترهای نام‌دار (Keyword Arguments)**

```python
def person_info(name, age):
    print(f"نام: {name}, سن: {age}")

person_info(age=25, name="رضا")  # ترتیب مهم نیست!
```

#### **ج) پارامترهای نامحدود (`*args` و `**kwargs`)\*\*

- `*args` برای دریافت لیستی از مقادیر:

  ```python
  def sum_all(*numbers):
      return sum(numbers)

  print(sum_all(1, 2, 3))  # خروجی: 6
  ```

- `**kwargs` برای دریافت دیکشنری از پارامترهای نام‌دار:

  ```python
  def show_info(**details):
      for key, value in details.items():
          print(f"{key}: {value}")

  show_info(name="مریم", age=30, city="تهران")
  ```

---

### **3. return**

اگر ما از تابع استفاده کنیم و دستور(return) را استفاده نکنیم و بعد تابع را صدا بزنیم اخر کلمه `none` را چاپ می کند

- همیشه لازم نیست از (return)استفاده شود

```py
def f():
    x = int(input("x :"))
    print(2 * x + 1)
f()
```

### **4. توابع بازگشتی (Recursive)**

تابعی که خودش را فراخوانی می‌کند.  
**مثال: محاسبه فاکتوریل:**

```python
def factorial(n):
    return 1 if n == 1 else n * factorial(n - 1)

print(factorial(5))  # 120
```
```py
#تابع عادی
def fact(x):
  f = 1
    for i in range(1, x+1):
      f += i
    return f
#تابع بازگشتی
def rec_fact(x):
  if x == 0 or x == 1:
    return 1
  return x * fact(x -1)
```

---

### **5. توابع لامبدا (Lambda)**

توابع کوچک و بی‌نام که با `lambda` تعریف می‌شوند:

```python
square = lambda x: x ** 2
print(square(4))  # 16
```

**کاربرد در `map` و `filter`:**

```python
numbers = [1, 2, 3]
squared = list(map(lambda x: x ** 2, numbers))  # [1, 4, 9]
```

---

### **6. دکوراتورها (Decorators)**

برای تغییر رفتار تابع بدون تغییر کد اصلی استفاده می‌شوند:

```python
def logger(func):
    def wrapper(*args, **kwargs):
        print(f"اجرای تابع {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@logger
def greet(name):
    print(f"سلام {name}!")

greet("علی")  # ابتدا "اجرای تابع greet" چاپ می‌شود.
```

---

### مثال

```py
f(x)= 2x+1
def f(x):
    return 2 x + 1
print(f(1))

#مثال 2:
def f(x):
    return 2 * x + 1
y = int(input("y :"))
f(y)
print(f(y))
#مثال 3:
def f():
    x = int(input("x :"))
    return 2 * x + 1
print(f())
```

---

### **نکات مهم:**

1. نام تابع باید توصیفی باشد (مثل `calculate_area` به جای `func1`).
2. از توابع برای تقسیم کد به بخش‌های منطقی استفاده کنید.
3. توابع باید تا حد امکان مستقل از متغیرهای خارجی باشند.

# یادداشت تابع (function annotation)

- در مقابل، پایتون به عنوان یک زبان داینامیک تایپ، به شما اجازه می‌دهد نوع پارامترها را مشخص نکنید و ارسال نوع داده اشتباه را در زمان اجرا تشخیص می‌دهد. این موضوع گاهی اوقات می‌تواند مشکل‌ساز باشد، زیرا ممکن است خطای نوع داده تا زمان اجرای برنامه مشخص نشود.

- برای حل این مشکل، پایتون از یادداشت تابع (Function Annotations) استفاده می‌کند. با استفاده از یادداشت تابع، می‌توان نوع پارامترها و نوع خروجی تابع را مشخص کرد.

- نکته مهم این است که یادداشت تابع در زمان اجرای عادی پایتون، هیچ تاثیری در عملکرد برنامه ندارد و صرفا برای راهنمایی برنامه‌نویس و ابزارهای توسعه مانند IDEها و Linterها استفاده می‌شود. برای مثال، PyCharm با استفاده از یادداشت تابع، می‌تواند خطاهای نوع داده را قبل از اجرا به شما نشان دهد.

- برای تشخیص خطاهای نوع داده در زمان اجرا، می‌توانید از ماژول mypy استفاده کنید. این ماژول با بررسی یادداشت تابع، خطاهای نوع داده را در زمان اجرا شناسایی می‌کند.

- نحوه تعریف نوع پارامترها با استفاده از یادداشت تابع به این صورت است که بعد از نام پارامتر، دو نقطه قرار داده و سپس نوع داده مورد نظر را می‌نویسیم.

- برای تعریف نوع خروجی تابع، باید بین دو نقطه و پرانتز تابع، یک فلش به سمت راست (->) قرار داده و سپس نوع داده خروجی را بنویسیم.

- همچنین می‌توان برای پارامترهای تابع، مقادیر پیش‌فرض تعیین کرد. در این صورت، اگر هنگام فراخوانی تابع، مقداری برای پارامتر ارسال نشود، از مقدار پیش‌فرض استفاده خواهد شد.

- برای مشاهده یادداشت تابع، می‌توان از **annotations** استفاده کرد.

- در نهایت، می‌توان از انواع داده مختلف مانند دیکشنری، لیست و تاپل در یادداشت تابع استفاده کرد.

- به طور کلی، استفاده از یادداشت تابع در پایتون، می‌تواند به خوانایی کد و جلوگیری از خطاهای نوع داده کمک کند.

## مثال

```py
#مثال ۱: تابع ساده با ورودی و خروجی عددی
def func(x: int, y: int, z: int) -> int:
    return x + y + z

print(func(1, 2, 3))
#در این مثال، تابع func سه پارامتر ورودی از نوع int دریافت می‌کند و خروجی آن نیز از نوع int است.

# مثال ۲: تابع با مقدار پیش‌فرض
def func(x: int = 10, y: int = 9, z: int = 5):
print(x, y, z)

func()
#در این مثال، برای هر یک از پارامترهای تابع func یک مقدار پیش‌فرض تعیین شده است. اگر تابع بدون ارسال آرگومان فراخوانی شود، از مقادیر پیش‌فرض استفاده خواهد شد.
#مثال ۳: تابع با نوع داده دیکشنری
def func(x: int, y: int, z: dict):
print(x)
print(y)
print(z)

func(1, 9, {})
#در این مثال، پارامتر z از نوع dict (دیکشنری) است.
# مثال ۴: تابع با نوع داده تاپل
def func(x: int, y: int, z: int) -> tuple:
    return (x+y+z, x, y, z)

print(func(1, 2, 5))
#در این مثال، نوع خروجی تابع func یک tuple (تاپل) است که شامل جمع سه عدد و خود اعداد می‌شود.


#    نکته: در تمامی این مثال‌ها، اگر نوع داده اشتباهی به تابع ارسال شود (مثلاً به جای عدد، رشته ارسال شود)، در زمان اجرای عادی پایتون خطایی رخ نمی‌دهد. اما اگر از ابزار mypy یا IDEهایی مانند PyCharm استفاده کنید، این خطاها قبل از اجرا یا در زمان اجرا شناسایی خواهند شد.
```

# توابع لامبدا

- لامبدا و کاربرد آن (map، filter، reduce و sorted)
- مفهوم توابع لامدا به عنوان توابع ناشناس و مختصر در پایتون توضیح داده می‌شود. این توابع برای مواقعی که نیاز به یک تابع کوچک و یکبار مصرف داریم، مفید هستند.

## 1. ساختار توابع لامدا:

توابع لامدا با استفاده از کلمه کلیدی lambda تعریف می‌شوند و ساختار آنها به صورت زیر است:
lambda arguments: expression

- توابع لامبدا توابع ناشناسی هستند که در یک خط نوشته می‌شوند و اسم ندارند. [1، 2] این توابع برای زمانی که به تابعی کوچک و یکبار مصرف نیاز دارید مفید هستند.

- **نحوه نوشتن یک تابع لامبدا:**

ابتدا کلمه کلیدی "لامبدا" را می‌نویسیم. سپس ورودی‌های تابع را با کاما از هم جدا می‌کنیم. بعد از ورودی‌ها، دو نقطه قرار می‌دهیم و در جلوی دو نقطه عبارت یا بدنه تابع را می‌نویسیم. نیازی به نوشتن دستور "ریترن" نیست زیرا به طور خودکار عبارت بعد از دو نقطه را برمی‌گرداند.

- ### Arguments: ورودی‌های تابع که با کاما از هم جدا می‌شوند.

- ### Expression: عبارتی که قرار است توسط تابع اجرا شود و نتیجه آن برگردانده شود.

  **نکات مهم:**

      1. توابع لامدا نیازی به نام ندارند.

      2. بدنه این توابع فقط شامل یک عبارت است.

      3. نیازی به استفاده از دستور return نیست، زیرا عبارت به صورت خودکار برگردانده می‌شود.

  **کاربردهای توابع لامدا:**

-توابع لامدا در کنار توابع و نوع‌های داخلی پایتون مانند map، filter، reduce و sorted کاربردهای فراوانی دارند.

## 2. دستورات لامدا

### 1. تابع map:

-تابع map دو آرگومان دریافت می‌کند: یک تابع و یک لیست. این تابع، عناصر لیست را یکی‌یکی به تابع ارسال می‌کند و نتیجه هر عنصر را در لیست جدیدی قرار می‌دهد.

```py
new_list = list(map(lambda x: x**2, my_list))

#در این مثال، هر عنصر لیست my_list به توان دو رسانده شده و نتیجه در لیست new_list قرار می‌گیرد.
```

### 2. تابع filter:

- تابع filter نیز دو آرگومان دریافت می‌کند: یک تابع و یک لیست. این تابع، عناصر لیست را یکی‌یکی به تابع ارسال می‌کند و اگر نتیجه تابع True باشد، عنصر را در لیست جدیدی قرار می‌دهد و در غیر این صورت آن را حذف می‌کند.

```py
new_list = list(filter(lambda x: x > 5, my_list))

#در این مثال، فقط عناصری از لیست my_list که بزرگتر از 5 هستند در لیست new_list قرار می‌گیرند.
```

### 3. تابع reduce:

- تابع reduce دو ورودی دریافت می‌کند: یک تابع و یک لیست. این تابع، دو عنصر اول لیست را به تابع ارسال می‌کند و نتیجه آن را با عنصر سوم لیست به تابع ارسال می‌کند و این کار را تا آخرین عنصر لیست ادامه می‌دهد.

```py
from functools import reduce

sum_of_list = reduce(lambda x, y: x + y, my_list)

#در این مثال، reduce جمع همه عناصر لیست my_list را محاسبه می‌کند.
```

### 4. تابع sorted:

- تابع sorted یک لیست را به عنوان ورودی دریافت می‌کند و یک لیست مرتب شده بر می‌گرداند. این تابع همچنین می‌تواند یک آرگومان اختیاری به نام key دریافت کند که یک تابع است و برای مرتب‌سازی عناصر لیست استفاده می‌شود.

```py
sorted_list = sorted(my_list, key=lambda x: len(x))

#در این مثال، sorted لیست my_list را بر اساس طول رشته‌ها مرتب می‌کند.
```

---

```python
lambda x: x ** 2
#در این مثال، تابع یک ورودی (x) می‌گیرد و آن را به توان دو می‌رساند.
```

**کاربردهای لامبدا:**

- **مپ:**
  تابع `map` یک تابع و یک لیست را به عنوان ورودی می‌گیرد. این تابع، تابع ورودی را روی تک تک عناصر لیست اعمال کرده و لیست جدیدی با نتایج برمی‌گرداند.

**مثال:**

```python
my_list =
new_list = list(map(lambda x: x ** 2, my_list))
print(new_list)  # Output:
```

در این مثال، تابع لامبدا هر عنصر از لیست را به توان دو می‌رساند و `map` این تابع را روی تمام عناصر لیست `my_list` اعمال می‌کند. [4، 6]

- **فیلتر:**
  تابع `filter` یک تابع و یک لیست را به عنوان ورودی می‌گیرد. این تابع، عناصری از لیست را که تابع ورودی برای آنها مقدار `True` را برمی‌گرداند، نگه می‌دارد و بقیه را حذف می‌کند.

**مثال:**

```python
my_list =
new_list = list(filter(lambda x: x > 5, my_list))
print(new_list)  # Output:
```

در این مثال، تابع لامبدا بررسی می‌کند که آیا هر عنصر از لیست بزرگتر از 5 است یا خیر. [6، 7] `filter` فقط عناصری را که تابع لامبدا برای آنها `True` را برمی‌گرداند، در لیست `new_list` قرار می‌دهد. [6، 7]

- **ریدیوس:**
  تابع `reduce` یک تابع و یک لیست را به عنوان ورودی می‌گیرد. این تابع، دو عنصر از لیست را به تابع ورودی ارسال می‌کند و نتیجه را با عنصر بعدی لیست ترکیب می‌کند تا در نهایت یک نتیجه نهایی به دست آید.

**مثال:**

```python
from functools import reduce
my_list =
result = reduce(lambda x, y: x + y, my_list)
print(result)  # Output: 10
```

در این مثال، تابع لامبدا دو ورودی (x و y) را دریافت کرده و آنها را با هم جمع می‌کند. [9، 10] `reduce` از این تابع برای جمع کردن تمام عناصر لیست `my_list` استفاده می‌کند.

- **مرتب‌سازی:**
  تابع `sorted` یک لیست و یک تابع (اختیاری) را به عنوان ورودی می‌گیرد. این تابع، لیست را بر اساس خروجی تابع ورودی مرتب می‌کند.

**مثال:**

```python
my_list =
new_list = sorted(my_list, key=lambda x: x % 3)
print(new_list)  # Output:
```

در این مثال، تابع لامبدا باقی مانده تقسیم هر عنصر از لیست بر 3 را برمی‌گرداند. `sorted` از این تابع برای مرتب‌سازی لیست `my_list` استفاده می‌کند. [10، 12]

**_نکته:_** در همه این مثال‌ها، به جای تعریف جداگانه تابع و ارسال آن به توابع `map`، `filter`، `reduce` و `sorted`، از توابع لامبدا برای تعریف تابع به صورت inline استفاده شده است. [6، 8، 10، 12]

# pass

از این دستور زمانی استفاده می کنیم که نمی خواهیم بدنه یک تابع یا حلقه ای را بنویسیم و بعدا بدنه ان را می نویسیم از این دستور استفاده می کنیم

- خلاصه‌ای از ویدیو به همراه دستورات مورد نیاز

# DocString

**هدف از داک‌استرینگ توضیح عملکرد یک تابع، کلاس یا ماژول برای کاربران و برنامه‌نویسانی است که ممکن است کد را ننوشته باشند.**

**داک‌استرینگ چگونه تعریف می‌شود؟**

- برای تعریف داک‌استرینگ، کافیست در خط اول بعد از تعریف تابع، کلاس یا ماژول، یک رشته با سه علامت نقل قول ("") یا سه علامت نقل قول دوتایی (""") بنویسید.
- توصیه می‌شود از سه علامت نقل قول دوتایی استفاده شود.
- متن داک‌استرینگ می‌تواند شامل خلاصه‌ای از عملکرد، پارامترهای ورودی، خروجی‌ها و توضیحات اضافی باشد.

**مثال:**

```python
def max_3(x, y, z):
    """
    این تابع سه عدد دریافت می‌کند و بزرگترین آنها را برمی‌گرداند.
    
    Args:
        x (int/float): اولین عدد
        y (int/float): دومین عدد
        z (int/float): سومین عدد
    
    Returns:
        int/float: بزرگترین عدد از بین سه عدد ورودی

    """
    return max(x, y, z)
```

**نکات مهم:**

- داک‌استرینگ باید اولین خط بعد از تعریف تابع، کلاس یا ماژول باشد.
- استفاده از داک‌استرینگ اختیاری است، اما توصیه می‌شود برای توابع، کلاس‌ها و ماژول‌ها داک‌استرینگ بنویسید.
- داک‌استرینگ با کامنت فرق دارد. کامنت برای توضیح نحوه کار کد برای برنامه‌نویسان است، در حالی که داک‌استرینگ برای توضیح عملکرد کد برای کاربران است.

**دستورات مورد نیاز برای دسترسی به داک‌استرینگ:**

- با استفاده از اتریبیوت `__doc__` :

```python
print(max_3.__doc__)
```

- با استفاده از تابع `help()` :

```python
help(max_3)
```

اکثر توابع داخلی پایتون دارای داک‌استرینگ هستند. برای مثال:

```python
print(len.__doc__)
print(print.__doc__)
print(max.__doc__)
```

# **تکرار (Iteration)**

در پایتون، **تکرار (Iteration)** به فرآیند اجرای مکرر یک بلوک کد گفته می‌شود. این کار معمولاً با استفاده از **حلقه‌ها (Loops)** یا **توابع بازگشتی (Recursive Functions)** انجام می‌شود. در اینجا به بررسی روش‌های مختلف تکرار در پایتون می‌پردازیم.

---

## **1. حلقه `for` — تکرار بر روی عناصر یک دنباله**

حلقه `for` برای **تکرار روی عناصر یک دنباله** (مانند لیست، رشته، تاپل، دیکشنری و ...) استفاده می‌شود.

### **سینتکس پایه:**

```python
for متغیر in دنباله:
    # کدی که تکرار می‌شود
```

### **مثال‌ها:**

#### **الف) تکرار روی لیست**

```python
fruits = ["سیب", "پرتقال", "موز"]
for fruit in fruits:
    print(fruit)
```

**خروجی:**

```
سیب
پرتقال
موز
```

#### **ب) تکرار روی رشته**

```python
name = "پایتون"
for char in name:
    print(char)
```

**خروجی:**

```
پ
ا
ی
ت
و
ن
```

#### **ج) تکرار روی دیکشنری**

```python
person = {"name": "علی", "age": 25, "city": "تهران"}
for key, value in person.items():
    print(f"{key}: {value}")
```

**خروجی:**

```
name: علی
age: 25
city: تهران
```

---

## **2. حلقه `while` — تکرار تا زمانی که شرط برقرار است**

حلقه `while` تا زمانی که **شرط آن `True` باشد** اجرا می‌شود.

### **سینتکس پایه:**

```python
while شرط:
    # کدی که تکرار می‌شود
```

### **مثال‌ها:**

#### **الف) شمارش معکوس**

```python
count = 5
while count > 0:
    print(count)
    count -= 1
```

**خروجی:**

```
5
4
3
2
1
```

#### **ب) دریافت ورودی تا زمانی که کاربر "exit" وارد کند**

```python
while True:
    user_input = input("یک عبارت وارد کنید (یا exit برای خروج): ")
    if user_input.lower() == "exit":
        break
    print(f"شما وارد کردید: {user_input}")
```

---

## **3. کنترل جریان حلقه‌ها (`break`, `continue`, `else`)**

### **الف) `break` — خروج زودهنگام از حلقه**

```python
for num in range(10):
    if num == 5:
        break  # حلقه در num=5 متوقف می‌شود
    print(num)
```

**خروجی:**

```
0
1
2
3
4
```

### **ب) `continue` — رد کردن یک تکرار**

```python
for num in range(10):
    if num % 2 == 0:
        continue  # اعداد زوج را رد می‌کند
    print(num)
```

**خروجی:**

```
1
3
5
7
9
```

### **ج) `else` — اجرای کد پس از اتمام حلقه**

```python
for num in range(3):
    print(num)
else:
    print("حلقه تمام شد!")
```

**خروجی:**

```
0
1
2
حلقه تمام شد!
```

---

## **4. توابع تکرارپذیر (`range`, `enumerate`, `zip`)**

### **الف) `range()` — تولید دنباله‌ای از اعداد**

```python
for i in range(5):       # 0 تا 4
    print(i)

for i in range(2, 6):    # 2 تا 5
    print(i)

for i in range(1, 10, 2): # 1 تا 9 با گام 2
    print(i)
```

### **ب) `enumerate()` — دریافت ایندکس و مقدار**

```python
fruits = ["سیب", "پرتقال", "موز"]
for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")
```

**خروجی:**

```
0: سیب
1: پرتقال
2: موز
```

### **ج) `zip()` — ترکیب دو لیست**

```python
names = ["علی", "رضا", "مریم"]
ages = [25, 30, 28]

for name, age in zip(names, ages):
    print(f"{name}: {age} سال")
```

**خروجی:**

```
علی: 25 سال
رضا: 30 سال
مریم: 28 سال
```

---

## **5. List Comprehension — تکرار فشرده برای ساخت لیست**

```python
# ساخت لیست مربع اعداد 0 تا 9
squares = [x**2 for x in range(10)]
print(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# فیلتر کردن اعداد فرد
odd_numbers = [x for x in range(10) if x % 2 != 0]
print(odd_numbers)  # [1, 3, 5, 7, 9]
```

---

## **6. توابع بازگشتی (Recursive Functions)**

تابعی که خودش را فراخوانی می‌کند.  
**مثال: محاسبه فاکتوریل**

```python
def factorial(n):
    return 1 if n == 1 else n * factorial(n - 1)

print(factorial(5))  # 120
```

---

## **نتیجه‌گیری**

| روش تکرار          | کاربرد                           |
| ------------------ | -------------------------------- |
| `for`              | تکرار روی عناصر یک دنباله        |
| `while`            | تکرار تا زمانی که شرط برقرار است |
| `break`            | خروج زودهنگام از حلقه            |
| `continue`         | رد کردن یک تکرار                 |
| `range()`          | تولید دنباله عددی                |
| `enumerate()`      | دریافت ایندکس و مقدار            |
| `zip()`            | ترکیب دو لیست                    |
| List Comprehension | ساخت لیست به صورت فشرده          |

# Decorator

کاربرد ات جا است که یک تابع داریم و می خواهیم کار قبلی را انحام دهد ولی یک دستور به ان اضافه شود

## دکوراتور چیست؟

- دکوراتور یک تابع است که یک تابع دیگر را به عنوان ورودی می‌گیرد و یک تابع جدید را بازمی‌گرداند.
- از دکوراتورها برای اضافه کردن قابلیت‌های جدید به توابع موجود استفاده می‌شود.
- با استفاده از @decorator_name قبل از تعریف تابع اعمال می‌شوند.

## دکوراتورهای استاندارد پایتون

برخی دکوراتورهای داخلی پایتون:

| دکوراتور      | کاربرد                    |
| ------------- | ------------------------- |
| @staticmethod | تعریف متد استاتیک در کلاس |
| @classmethod  | تعریف متد کلاس            |
| @property     | تعریف ویژگی‌های کلاس      |

## کاربردهای رایج دکوراتورها

1. لاگ کردن (ثبت اطلاعات اجرا)

2. اعتبارسنجی (مثلاً چک کردن ورودی‌ها)

3. کش کردن (ذخیره نتایج برای عملکرد بهتر)

4. تعیین سطح دسترسی (مثلاً چک کردن لاگین کاربر)

5. تایمر (اندازه‌گیری زمان اجرا)

## فرم کلی

```py
import functools

def Decorator(func):
@functools.warps(func)
def warpper_decorator(*Args, **kwargs):
    #do somthing before
    value = func(*Args, **kwargs):
    # do somthing after
    return value
return warpper_decorator
```

## مثال :

```py

def dec(func):
    def inner(x, y):
        if y == 0:
            return "warning!!!"
        return func(x, y)
    return inner

@dec
def f(x, y)
    return x/y

print(f(10, 12))
#برای انکه بتوانیم از تابع بالا هر جا که خواستیم استفاده کنیم باید در تعریف متغیر (قبل ) از * استافده کنیم
```

```py
def dec(func):
    def inner(*x, **y):
        if y == 0:
            return "warning!!!"
        return func(x, y)
    return inner

@dec
def f(x, y, z)
    return x/y+2

print(f(10, 12, 0))
```

## نکات مهم

- دکوراتورها می‌توانند تابع یا کلاس را تغییر دهند.

- ترتیب اعمال دکوراتورها مهم است (@A @B def f() معادل A(B(f)) است).

- برای حفظ متادیتاهای تابع اصلی (مثل **name**) از functools.wraps استفاده کنید.

مثال با functools.wraps:

```py
from functools import wraps

def debug(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"فراخوانی {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@debug
def say_hello():
    """این تابع سلام می‌کند"""
    print("سلام!")

print(say_hello.__name__)  # خروجی: say_hello (بدون wraps میشد wrapper)
print(say_hello.__doc__)   # خروجی: این تابع سلام می‌کند
```

## جمع‌بندی

| مفهوم               | مثال              | کاربرد                   |
| ------------------- | ----------------- | ------------------------ |
| دکوراتور ساده       | @decorator        | اضافه کردن قابلیت جدید   |
| دکوراتور با پارامتر | @decorator(arg)   | پیکربندی دکوراتور        |
| چند دکوراتور        | @A @B def f()     | ترکیب قابلیت‌ها          |
| @property           | @property def x() | کنترل دسترسی به ویژگی‌ها |

# ژنراتورها (Generators)

## 1. ژنراتور

- **تابع ویژه‌ای** که به جای `return` از `yield` استفاده می‌کند.
- **مقادیر را به صورت تنبل (Lazy Evaluation)** تولید می‌کند (یعنی فقط وقتی درخواست شود).
- **حافظه را بهینه می‌کند** (برای داده‌های حجیم ایده‌آل است).

---

## 2. ساخت ژنراتور

### تابع ژنراتور (با `yield`)

```python
def count_up_to(n):
    num = 1
    while num <= n:
        yield num  # مقدار را برمی‌گرداند و مکث می‌کند
        num += 1

# استفاده:
counter = count_up_to(5)
print(next(counter))  # 1
print(next(counter))  # 2
```

---

## 3. تفاوت ژنراتور با لیست معمولی

| ویژگی      | لیست                        | ژنراتور                  |
| ---------- | --------------------------- | ------------------------ |
| **حافظه**  | تمام مقادیر را ذخیره می‌کند | فقط یک مقدار در هر زمان  |
| **سرعت**   | سریع برای دسترسی تصادفی     | سریع برای پردازش ترتیبی  |
| **کاربرد** | داده‌های کوچک               | داده‌های حجیم یا بینهایت |

**مثال: تولید اعداد بینهایت**

```python
def infinite_numbers():
    num = 0
    while True:
        yield num
        num += 1

gen = infinite_numbers()
print(next(gen))  # 0
print(next(gen))  # 1
# ادامه دارد...
```

---

## 4. مثال

### الف) پردازش فایل‌های حجیم

```python
def read_large_file(file_path):
    with open(file_path, 'r') as file:
        for line in file:
            yield line.strip()

# استفاده بدون مصرف حافظه زیاد:
for line in read_large_file('data.txt'):
    print(line)
```

### ب) تولید دنباله‌های ریاضی

```python
def fibonacci(limit):
    a, b = 0, 1
    while a < limit:
        yield a
        a, b = b, a + b

print(list(fibonacci(50)))  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
```

### ج) خط لوله پردازش داده (Pipeline)

```python
def numbers():
    yield from range(10)

def squared(nums):
    for n in nums:
        yield n**2

def even(nums):
    for n in nums:
        if n % 2 == 0:
            yield n

# ترکیب ژنراتورها:
result = even(squared(numbers()))
print(list(result)))  # [0, 4, 16, 36, 64]
```

### ه) ژنراتور برای فیلتر کردن داده‌ها

```python
def filter_data(data, condition):
    for item in data:
        if condition(item):
            yield item

data = [10, 4, 7, 18, 2]
filtered = filter_data(data, lambda x: x > 5)
print(list(filtered)))  # [10, 7, 18]
```

### مثال های بیشتر

```py
def func(x):
    print("reza")
    yield x**2
    print("hello")
    yield 5
    print("ok")
    yield x-2

x = func(5)
next(x)
next(x)
next(x)

#output
#    reza
#    hello
#    ok
```

```py
def func(x):
    print("reza")
    yield x**2
    print("hello")
    yield 5
    print("ok")
    yield x-2

x = func(5)
    print(next(x))
    print(next(x))

#output
#    reza
#    25

#    hello
#    5
```

```py
def func():
    for i in range(1000):
        yield i**2

g = func()
print(next(g))
print(next(g))
.
.
.

```

```py
#جلوگیری از خطای استاب ایتریشن
def my_generator():
    print("welcome!")
    for i in range(5):
    yield i **2

g = my_generator()
iter_ = iter([1, 2, 3])

for i in g:
    print(i)
```

---

## 5. تفاوت `yield` و `return`

| ویژگی         | `yield`                         | `return`                |
| ------------- | ------------------------------- | ----------------------- |
| **حالت تابع** | تابع به حالت تعلیق درمی‌آید     | تابع خاتمه می‌یابد      |
| **مقادیر**    | چندین مقدار تولید می‌کند        | یک مقدار برمی‌گرداند    |
| **حافظه**     | مقادیر را یک به یک تولید می‌کند | همه را یکجا برمی‌گرداند |

---

## خلاصه

- **ژنراتور = تابع + `yield`**
- **بهینه برای داده‌های حجیم**
- **ترکیب‌پذیر با `for` و سایر ژنراتورها**
- **مصرف با `next()` یا حلقه‌ها**

# متت های لیست
در پایتون، لیست (List) یکی از ساختارهای داده‌ای پرکاربرد است که متدهای (methods) مختلفی برای مدیریت و دستکاری عناصر آن وجود دارد. در زیر مهم‌ترین متدهای لیست در پایتون را بررسی می‌کنیم:

### **۱. متدهای اضافه کردن عناصر**
- **`append(x)`**  
  یک عنصر `x` را به **انتهای** لیست اضافه می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.append(4)
  print(lst)  # خروجی: [1, 2, 3, 4]
  ```

- **`extend(iterable)`**  
  عناصر یک لیست یا شیء قابل پیمایش (iterable) را به انتهای لیست اضافه می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.extend([4, 5])
  print(lst)  # خروجی: [1, 2, 3, 4, 5]
  ```

- **`insert(i, x)`**  
  عنصر `x` را در **موقعیت `i`** درج می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.insert(1, 99)
  print(lst)  # خروجی: [1, 99, 2, 3]
  ```

### **۲. متدهای حذف عناصر**
- **`remove(x)`**  
  اولین عنصر با مقدار `x` را حذف می‌کند. اگر عنصر وجود نداشته باشد، `ValueError` می‌دهد.  
  مثال:
  ```python
  lst = [1, 2, 3, 2]
  lst.remove(2)
  print(lst)  # خروجی: [1, 3, 2]
  ```

- **`pop([i])`**  
  عنصر در **موقعیت `i`** را حذف و برمی‌گرداند. اگر `i` مشخص نشود، آخرین عنصر حذف می‌شود.  
  مثال:
  ```python
  lst = [1, 2, 3, 4]
  x = lst.pop(1)
  print(x)    # خروجی: 2
  print(lst)  # خروجی: [1, 3, 4]
  ```

- **`clear()`**  
  تمام عناصر لیست را حذف می‌کند و لیست خالی می‌شود.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.clear()
  print(lst)  # خروجی: []
  ```

### **۳. متدهای جستجو و اطلاعات**
- **`index(x[, start[, end]])`**  
  اولین ایندکس عنصر `x` را برمی‌گرداند. اگر وجود نداشته باشد، `ValueError` می‌دهد.  
  مثال:
  ```python
  lst = [10, 20, 30, 20]
  print(lst.index(20))       # خروجی: 1
  print(lst.index(20, 2))    # خروجی: 3 (جستجو از ایندکس 2)
  ```

- **`count(x)`**  
  تعداد تکرارهای عنصر `x` در لیست را برمی‌گرداند.  
  مثال:
  ```python
  lst = [1, 2, 2, 3, 2]
  print(lst.count(2))  # خروجی: 3
  ```

### **۴. متدهای مرتب‌سازی و تغییر ترتیب**
- **`sort(key=None, reverse=False)`**  
  لیست را **به‌صورت درجا** (in-place) مرتب می‌کند.  
  مثال:
  ```python
  lst = [3, 1, 4, 2]
  lst.sort()
  print(lst)  # خروجی: [1, 2, 3, 4]
  ```

- **`reverse()`**  
  ترتیب عناصر لیست را معکوس می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst.reverse()
  print(lst)  # خروجی: [3, 2, 1]
  ```

  ### تفاوت `reverse()` و `reversed()`:
  - **`list.reverse()`**:  
    - یک **متد لیست** است و لیست را **درجا (in-place)** معکوس می‌کند (یعنی لیست اصلی تغییر می‌کند).  
    - مقدار بازگشتی ندارد (`None` برمی‌گرداند).  
    مثال:
    ```python
    lst = [1, 2, 3]
    lst.reverse()
    print(lst)  # خروجی: [3, 2, 1] (لیست اصلی تغییر کرد)
    ```

  - **`reversed(list)`**:  
    - یک **تابع built-in** است و لیست اصلی را تغییر **نمی‌دهد**.  
    - یک **iterator** برمی‌گرداند که عناصر را به صورت معکوس می‌دهد.  
    - برای تبدیل به لیست، باید از `list()` استفاده کرد.  
    مثال:
    ```python
    lst = [1, 2, 3]
    reversed_lst = reversed(lst)  # یک iterator برمی‌گرداند
    print(list(reversed_lst))     # خروجی: [3, 2, 1]
    print(lst)                   # خروجی: [1, 2, 3] (لیست اصلی تغییر نکرده)
    ```

  ### کاربرد `reversed()`:
  - وقتی می‌خواهید لیست را معکوس کنید **بدون تغییر لیست اصلی**.  
  - مناسب برای حلقه‌های معکوس:
    ```python
    for item in reversed([1, 2, 3]):
        print(item)  # چاپ: 3, 2, 1
    ```

  ### مثال‌های بیشتر:
  ```python
  # معکوس کردن یک رشته
  s = "hello"
  print(list(reversed(s)))  # ['o', 'l', 'l', 'e', 'h']
  print(''.join(reversed(s)))  # 'olleh'

  # معکوس کردن تاپل
  t = (1, 2, 3)
  print(tuple(reversed(t)))  # (3, 2, 1)
  ```

### **۵. متدهای کپی و ایجاد لیست جدید**
- **`copy()`**  
  یک **کپی سطحی** (shallow copy) از لیست ایجاد می‌کند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  lst2 = lst.copy()
  print(lst2)  # خروجی: [1, 2, 3]
  ```

### **۶. سایر متدهای مفید**
- **`len(list)`** (تابع built-in)  
  تعداد عناصر لیست را برمی‌گرداند.  
  مثال:
  ```python
  lst = [1, 2, 3]
  print(len(lst))  # خروجی: 3
  ```

- **`max(list)` و `min(list)`** (توابع built-in)  
  بزرگترین و کوچکترین عنصر لیست را برمی‌گردانند.  
  مثال:
  ```python
  lst = [5, 2, 8, 1]
  print(max(lst))  # خروجی: 8
  print(min(lst))  # خروجی: 1
  ```

### **جمع‌بندی**
| متد | توضیح |
|------|------|
| `append(x)` | اضافه کردن `x` به انتهای لیست |
| `extend(iterable)` | اضافه کردن چند عنصر به لیست |
| `insert(i, x)` | درج `x` در موقعیت `i` |
| `remove(x)` | حذف اولین عنصر با مقدار `x` |
| `pop([i])` | حذف و برگرداندن عنصر در موقعیت `i` |
| `clear()` | خالی کردن لیست |
| `index(x)` | یافتن ایندکس اولین وقوع `x` |
| `count(x)` | شمارش تعداد تکرار `x` |
| `sort()` | مرتب‌سازی لیست |
| `reverse()` | معکوس کردن ترتیب لیست |
| `copy()` | ایجاد کپی از لیست |

# متد های تاپل و مجموعه ها
---

##  **متدهای تاپل (Tuple Methods)**  
تاپل‌ها **Immutable** هستند، بنابراین متدهای تغییردهنده (مانند `append()` یا `remove()`) را ندارند.

### ۱- **`count(x)`**  
تعداد تکرارهای عنصر `x` در تاپل را برمی‌گرداند.  
```python
t = (1, 2, 2, 3, 2)
print(t.count(2))  # خروجی: 3
```

### ۲- **`index(x)`**  
اولین ایندکس عنصر `x` را برمی‌گرداند. اگر وجود نداشته باشد، `ValueError` می‌دهد.  
```python
t = (10, 20, 30, 20)
print(t.index(20))  # خروجی: 1
```

###  **نکته مهم:**  
- تاپل‌ها متدهای `append()`، `remove()`، `sort()` و ... **ندارند** چون غیرقابل تغییر هستند.  
- اگر نیاز به تغییر دارید، باید تاپل را به لیست تبدیل کنید و دوباره تاپل بسازید:
  ```python
  t = (1, 2, 3)
  lst = list(t)
  lst.append(4)
  t = tuple(lst)
  print(t)  # خروجی: (1, 2, 3, 4)
  ```

---

##  **متدهای مجموعه (Set Methods)**  
مجموعه‌ها (**Set**) **ترتیب ندارند** و **عناصر تکراری** را ذخیره نمی‌کنند. متدهای اصلی آنها:

### ۱- **اضافه و حذف عناصر**  
| متد | توضیح |
|------|-------|
| `add(x)` | اضافه کردن `x` به مجموعه |
| `remove(x)` | حذف `x` از مجموعه (اگر نباشد `KeyError` می‌دهد) |
| `discard(x)` | حذف `x` از مجموعه (اگر نباشد خطا نمی‌دهد) |
| `pop()` | یک عنصر **تصادفی** حذف و برمی‌گرداند |
| `clear()` | پاک کردن تمام مجموعه |

مثال:
```python
s = {1, 2, 3}
s.add(4)       # {1, 2, 3, 4}
s.remove(2)    # {1, 3, 4}
s.discard(99)  # خطا نمی‌دهد
print(s.pop()) # یک عنصر تصادفی برمی‌گرداند
```

### ۲- **عملیات مجموعه‌ها**  
| متد | توضیح |
|------|-------|
| `union(other_set)` | اجتماع دو مجموعه (`|`) |
| `intersection(other_set)` | اشتراک دو مجموعه (`&`) |
| `difference(other_set)` | تفاوت دو مجموعه (`-`) |
| `symmetric_difference(other_set)` | تفاضل متقارن (`^`) |
| `update(other_set)` | اضافه کردن همه عناصر `other_set` به مجموعه فعلی |

مثال:
```python
A = {1, 2, 3}
B = {3, 4, 5}
print(A.union(B))            # {1, 2, 3, 4, 5}
print(A.intersection(B))     # {3}
print(A.difference(B))       # {1, 2}
print(A.symmetric_difference(B))  # {1, 2, 4, 5}
```

### ۳- **متدهای بررسی**  
| متد | توضیح |
|------|-------|
| `issubset(other_set)` | آیا مجموعه زیرمجموعه `other_set` است؟ |
| `issuperset(other_set)` | آیا مجموعه ابرمجموعه `other_set` است؟ |
| `isdisjoint(other_set)` | آیا دو مجموعه اشتراکی ندارند؟ |

مثال:
```python
A = {1, 2}
B = {1, 2, 3}
print(A.issubset(B))    # True
print(B.issuperset(A))  # True
print(A.isdisjoint({4, 5}))  # True
```


#### **4- متد `difference()`**  
تفاوت دو مجموعه را برمی‌گرداند (عناصری که در مجموعه اول هستند ولی در مجموعه دوم نیستند).  
✅ **تغییری در مجموعه اصلی ایجاد نمی‌کند.**  
```python
s = {1, 2, 3, 4}
x = {3, 4, 5, 6}
print(s.difference(x))  # خروجی: {1, 2}
print(s)  # خروجی: {1, 2, 3, 4} (مجموعه اصلی تغییر نکرده)
```

#### **5- متد `difference_update()`**  
تفاوت دو مجموعه را محاسبه کرده و **تغییرات را روی مجموعه اصلی اعمال می‌کند.**  
❌ **مجموعه اصلی را تغییر می‌دهد و مقدار بازگشتی ندارد (`None`).**  
```python
s = {1, 2, 3, 4}
x = {3, 4, 5, 6}
s.difference_update(x)  # اعمال تغییرات روی s
print(s)  # خروجی: {1, 2} (مجموعه اصلی تغییر کرد)
```

#### **6- متد `isdisjoint()`**  
اگر دو مجموعه **هیچ عنصر مشترکی نداشته باشند**، `True` برمی‌گرداند.  
```python
s = {1, 2, 3, 4}
x = {5, 6, 7}
print(s.isdisjoint(x))  # خروجی: True (چون اشتراکی ندارند)

y = {3, 4, 5}
print(s.isdisjoint(y))  # خروجی: False (چون ۳ و ۴ مشترک هستند)
```

---

### **جمع‌بندی متدهای مجموعه (Set)**
| متد | توضیح | تغییر در مجموعه اصلی؟ |
|------|-------|------------------|
| `difference()` | تفاوت دو مجموعه را برمی‌گرداند | ❌ |
| `difference_update()` | تفاوت را روی مجموعه اصلی اعمال می‌کند | ✅ |
| `isdisjoint()` | بررسی عدم اشتراک دو مجموعه | ❌ |


---


### **جمع‌بندی:**
| نوع | مهم‌ترین متدها |
|------|---------------|
| **تاپل** | `count()`, `index()` |
| **مجموعه** | `add()`, `remove()`, `union()`, `intersection()`, `difference()` |


---
# متد های دیکشنری

## **متدهای اصلی دیکشنری**

### 1. **`keys()`**  
تمام کلیدهای دیکشنری را به صورت یک شیء `dict_keys` برمی‌گرداند.  
```python
d = {'a': 1, 'b': 2, 'c': 3}
print(d.keys())  # خروجی: dict_keys(['a', 'b', 'c'])
```

### 2. **`values()`**  
تمام مقادیر دیکشنری را به صورت یک شیء `dict_values` برمی‌گرداند.  
```python
print(d.values())  # خروجی: dict_values([1, 2, 3])
```

### 3. **`items()`**  
تمام زوج‌های `(key, value)` را به صورت یک شیء `dict_items` برمی‌گرداند.  
```python
print(d.items())  # خروجی: dict_items([('a', 1), ('b', 2), ('c', 3)])
```

### 4. **`get(key[, default])`**  
مقدار متناظر با `key` را برمی‌گرداند. اگر کلید وجود نداشته باشد، `default` (پیش‌فرض: `None`) برگردانده می‌شود.  
- (کلید را مشخص می کنیم ومقدار ان را برمی‌گرداند)
```python
print(d.get('a'))     # خروجی: 1
print(d.get('x', 0))  # خروجی: 0 (چون 'x' وجود ندارد)
```
```py
d = {"a":1, "b":2}
  print(d.get("c",میتوان در صورت نان بودن یک چیزی برمی گرداند))
```
### 5. **`setdefault(key[, default])`**  
- اگر `key` وجود داشته باشد، مقدار آن را برمی‌گرداند.  
- اگر وجود نداشته باشد، کلید را با مقدار `default` (پیش‌فرض: `None`) اضافه می‌کند.  
```python
d.setdefault('b', 0)  # 'b' وجود دارد، پس مقدار 2 برمی‌گردد
d.setdefault('x', 10) # 'x' اضافه می‌شود: {'a':1, 'b':2, 'c':3, 'x':10}
```
```py
d = {"a":1, "b":2}
  print(d.setdefault("d",0))
```

### 6. **`update([other])`**  
دیکشنری را با زوج‌های `(key, value)` از `other` (دیکشنری یا شیء قابل پیمایش) به‌روز می‌کند.  
- یک دیکشنری جدید می گیرد و به دیکشنری قبیل اضافه می کند
```python
d.update({'b': 20, 'd': 4})  # d میشود: {'a':1, 'b':20, 'c':3, 'x':10, 'd':4}
```
```py
d = {"a":1, "b":2}
d.update{"z":0, "k":5, "l":7}

#2
d = {"a":1, "b":2}
d.update{"a":0, "k":5, "l":7}
```
### 7. **`pop(key[, default])`**  
کلید `key` را حذف و مقدار آن را برمی‌گرداند. اگر کلید وجود نداشته باشد و `default` مشخص نشده باشد، `KeyError` می‌دهد.  
```python
val = d.pop('b')  # val = 20, d حذف میشود: {'a':1, 'c':3, 'x':10, 'd':4}
# example-2
d = {"a":1, "b":2}
  print(d.pop("a"))
```

### 8. **`popitem()`**  
یک زوج `(key, value)` را به صورت **تصادفی** (در نسخه‌های جدید، آخرین عنصر) حذف و برمی‌گرداند. اگر دیکشنری خالی باشد، `KeyError` می‌دهد.  
```python
item = d.popitem()  # مثلاً: ('d', 4)
```

### 9. **`clear()`**  
تمام عناصر دیکشنری را پاک می‌کند.  
```python
d.clear()  # d میشود: {}
```

### 10. **`copy()`**  
یک کپی سطحی (Shallow Copy) از دیکشنری ایجاد می‌کند.  
```python
d = {'a': 1, 'b': [2, 3]}
d_copy = d.copy()
```

### 11. **`fromkeys(iterable[, value])`** (متد کلاس)  
یک دیکشنری جدید با کلیدهای از `iterable` و مقادیر یکسان `value` (پیش‌فرض: `None`) می‌سازد.  
```python
keys = ['a', 'b', 'c']
new_dict = dict.fromkeys(keys, 0)  # {'a': 0, 'b': 0, 'c': 0}
```

---

##  **متدهای بررسی و کاربردهای پیشرفته**

### 12. **`len(dict)`**  
تعداد کلیدهای دیکشنری را برمی‌گرداند.  
```python
print(len({'a': 1, 'b': 2}))  # خروجی: 2
```

### 13. **`in` Operator**  
بررسی وجود یک کلید در دیکشنری.  
```python
d = {'a': 1}
print('a' in d)  # True
```

### 14. **حلقه بر روی دیکشنری**  
- کلیدها:  
  ```python
  for key in d:
      print(key, d[key])
  ```
- مقادیر:  
  ```python
  for value in d.values():
      print(value)
  ```
- کلید و مقدار:  
  ```python
  for key, value in d.items():
      print(key, value)
  ```

---

##  **تفاوت `copy()` و `deepcopy()`**
- **`copy()`**: کپی سطحی (تغییر در لیست‌های تو در تو تأثیرگذار است).  
- **`deepcopy()` (از ماژول `copy`)**: کپی عمیق (تمامی سطوح کپی می‌شوند).  
```python
import copy
d = {'a': [1, 2]}
d_shallow = d.copy()
d_deep = copy.deepcopy(d)
```

---

## 📊 **جمع‌بندی متدهای دیکشنری**
| متد | توضیح | مثال |
|------|--------|------|
| `keys()` | لیست کلیدها | `dict.keys()` |
| `values()` | لیست مقادیر | `dict.values()` |
| `items()` | لیست زوج‌های کلید-مقدار | `dict.items()` |
| `get()` | دریافت مقدار با کلید | `dict.get('a', 0)` |
| `setdefault()` | اضافه کردن کلید با مقدار پیش‌فرض | `dict.setdefault('x', 10)` |
| `update()` | به‌روزرسانی دیکشنری | `dict.update({'b': 20})` |
| `pop()` | حذف کلید و برگشت مقدار | `dict.pop('a')` |
| `popitem()` | حذف و برگشت آخرین عنصر | `dict.popitem()` |
| `clear()` | پاک کردن دیکشنری | `dict.clear()` |
| `copy()` | کپی سطحی | `dict.copy()` |
| `fromkeys()` | ساخت دیکشنری جدید | `dict.fromkeys(['a', 'b'], 0)` |

# متد رشته
---


## **1. تبدیل حروف و نرمال‌سازی**  
این متدها برای تغییر حالت حروف (بزرگ/کوچک) و یکسان‌سازی متن استفاده می‌شوند.  

| متد | توضیح | مثال | تفاوت‌های کلیدی |
|------|--------|------|----------------|
| **`upper()`** | تبدیل به حروف بزرگ | `"hello".upper() → "HELLO"` | - |
| **`lower()`** | تبدیل به حروف کوچک | `"HELLO".lower() → "hello"` | فقط برای انگلیسی بهینه است. |
| **`casefold()`** | مثل `lower()` اما برای زبان‌های غیرانگلیسی | `"HELLO ß".casefold() → "hello ss"` | `ß` در آلمانی به `ss` تبدیل می‌شود. |
| **`capitalize()`** | اولین حرف بزرگ، بقیه کوچک | `"hello".capitalize() → "Hello"` | - |
| **`title()`** | اولین حرف هر کلمه بزرگ | `"hello world".title() → "Hello World"` | - |
| **`swapcase()`** | معکوس کردن حروف بزرگ/کوچک | `"Hello".swapcase() → "hELLO"` | - |

---

## **2. جستجو و بررسی محتوا**  
برای پیدا کردن زیررشته‌ها و اعتبارسنجی محتوا.  

| متد | توضیح | مثال | تفاوت‌های کلیدی |
|------|--------|------|----------------|
| **`find(sub)`** | ایندکس اولین وقوع زیررشته | `"hello".find("e") → 1` | اگر نباشد `-1` برمی‌گرداند. |
| **`index(sub)`** | مثل `find()` اما با `ValueError` | `"hello".index("e") → 1` | اگر نباشد خطا می‌دهد. |
| **`count(sub)`** | شمارش تکرار زیررشته | `"hello".count("l") → 2` | - |
| **`startswith(prefix)`** | آیا رشته با پیشوند شروع می‌شود؟ | `"hello".startswith("he") → True` | - |
| **`endswith(suffix)`** | آیا رشته با پسوند پایان می‌یابد؟ | `"hello".endswith("lo") → True` | - |
| **`isalpha()`** | آیا همه کاراکترها حروف الفبا هستند؟ | `"abc".isalpha() → True` | - |
| **`isascii()`** | آیا همه کاراکترها در محدوده ASCII هستند؟ | `"hello".isascii() → True` | - |
| **`isdigit()`** | آیا همه کاراکترها رقم هستند؟ | `"123".isdigit() → True` | فقط اعداد عربی (`0-9`). |
| **`isdecimal()`** | مثل `isdigit()` اما برای اعداد عربی/فارسی | `"۱۲۳".isdecimal() → True` | - |
| **`isnumeric()`** | گسترده‌تر از `isdigit()` (شامل رقم‌های چینی، رومی و ...) | `"四".isnumeric() → True` | - |

---

## 3. **اصلاح و فرمت‌دهی متن**
برای تغییر ظاهر رشته و ساخت متن‌های پویا.  

| متد | توضیح | مثال | تفاوت‌های کلیدی |
|------|--------|------|----------------|
| **`strip()`** | حذف فاصله از دو طرف | `"  hello  ".strip() → "hello"` | - |
| **`split(sep)`** | تقسیم رشته به لیست | `"a,b,c".split(",") → ["a","b","c"]` | - |
| **`join(list)`** | اتصال لیست به رشته | `"-".join(["a","b"]) → "a-b"` | - |
| **`replace(old, new)`** | جایگزینی زیررشته | `"hello".replace("e","a") → "hallo"` | - |
| **`center(width, fill)`** | چینش متن در وسط با کاراکتر پرکننده | `"hi".center(6, "+") → "++hi++"` | - |
| **`expandtabs(n)`** | جایگزینی تب (`\t`) با `n` فاصله | `"a\tb".expandtabs(4) → "a    b"` | - |
| **`format()`** | جایگزینی مقادیر در متن | `"{}".format(1) → "1"` | - |
| **`format_map(dict)`** | جایگزینی با دیکشنری | `"{name}".format_map({"name":"Ali"}) → "Ali"` | - |

---

## **🔹 نکات کلیدی و تفاوت‌های مهم**  

### **✅ `casefold()` vs `lower()`**  
- `casefold()` برای **زبان‌های غیرانگلیسی** (مثل آلمانی) بهتر است.  
- `lower()` فقط حروف انگلیسی را پشتیبانی می‌کند.  

### **✅ `isdigit()` vs `isdecimal()` vs `isnumeric()`**  
| متد | پشتیبانی از اعداد فارسی/عربی | پشتیبانی از اعداد دیگر زبان‌ها |
|------|----------------|----------------|
| `isdigit()` | ❌ خیر | ❌ خیر |
| `isdecimal()` | ✅ بله | ❌ خیر |
| `isnumeric()` | ✅ بله | ✅ بله (مثل چینی "四") |

---

## **📊 جمع‌بندی نهایی**  
- **برای تغییر حروف:** `upper()`, `lower()`, `casefold()`  
- **برای جستجو:** `find()`, `index()`, `count()`  
- **برای بررسی محتوا:** `isalpha()`, `isdigit()`, `isnumeric()`  
- **برای فرمت‌دهی:** `format()`, `format_map()`, `center()`  


---
# عملگر والروس
با عملگر والروس می توان همزمان مقدار دهی کرد و استفده کرد
## **کاربرد اصلی**  
- **مشکل قدیمی:**  
  در گذشته، برای اختصاص یک مقدار و استفاده از آن در یک شرط، مجبور بودیم دو خط کد بنویسیم:  
  ```python
  number = input("عدد وارد کنید: ")
  if int(number) > 10:
      print("بزرگتر از ۱۰")
  ```  

- **راه حل با والروس:**  
  با `:=` می‌توان هر دو کار را **در یک خط** انجام داد:  
  ```python
  if (number := int(input("عدد وارد کنید: "))) > 10:
      print("بزرگتر از ۱۰")
  ```  
  - مقدار `input` مستقیماً به `number` اختصاص می‌یابد و در شرط استفاده می‌شود.  

---

## مثال‌های کاربردی

### ۱. **حلقه‌های `while` با خواندن مقادیر**  
```python
while (line := input("متن را وارد کنید (خروج: enter): ")) != "":
    print(f"شما نوشتید: {line}")
```

### ۲. **محاسبات سنگین را یک بار انجام دهید و نتیجه را ذخیره کنید**  
```python
if (result := some_expensive_calculation()) > 100:
    print(f"نتیجه بزرگ است: {result}")
```

### ۳. **فیلتر کردن لیست‌ها با اختصاص ضمنی**  
```python
numbers = [12, 34, 1, 5, 90]
filtered = [n for n in numbers if (sqrt := n ** 0.5) > 5]
print(filtered)  # اعدادی که جذر آنها بزرگتر از ۵ است
```

---

## محدودیت‌ها و نکات مهم
- **پایتون ۳.۸+:** این عملگر فقط در نسخه‌های جدید پایتون کار می‌کند.  
- **خوانایی کد:** اگر استفاده از آن باعث گیجی شود، بهتر است از روش سنتی (دو خطی) استفاده کنید.  
- **پرانتز ضروری است:** برای جلوگیری از ابهام، باید حول عبارت والروس پرانتز بگذارید:  
  ```python
  # ✅ صحیح
  if (x := 10) > 5:
      print(x)

  # ❌ غلط (خطای نحوی)
  if x := 10 > 5:
      print(x)
  ```

---

### **🔹 چه زمانی از والروس استفاده کنیم؟**  
- وقتی می‌خواهید **کد را فشرده‌تر** کنید.  
- وقتی **مقدار محاسبه‌شده** را **بعداً** در کد نیاز دارید.  
- در **شرط‌ها** یا **حلقه‌های** پیچیده.  

### **🔹 چه زمانی استفاده نکنیم؟**  
- اگر باعث **کاهش خوانایی** کد شود.  
- اگر نیاز به **پشتیبانی از پایتون قدیمی** دارید.  

--- 

# تابع open( )

تابع `open()` : این تابع امکان خواندن، نوشتن و مدیریت فایل‌ها را فراهم می‌کند.
1. پارامتر های 2 و 3 و 4 و 5 و 6 و 8 ***اختیاری*** است
2. پارامتر 7 اختیاری است و به صورت پش فرض **True**
3. پارامتر 1 **الزامی** است
## ساختار کلی تابع

```python
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
```
- تابع open()  را می توان به دو روش باز/استفاده کرد
1. تعریف متغیر 
```py
file = open('data.tet')
```
2. استفاده از دستور `with`
```py 
with open('data.tet') as file
```

## پارامترهای تابع open( )

### 1. پارامتر `file` 
- مسیر فایل را مشخص می‌کند
- می‌تواند به صورت نسبی یا مطلق باشد
- مثال:
  ```python
  # مسیر نسبی
  file = open('data.txt')
  
  # مسیر مطلق
  file = open('/path/to/your/file.txt')
  ```

### 2. پارامتر `mode` 
پارامتر `mode` ***اختیاری*** است و به صورت پیشفرض از حالت پایه ی `r` استفاده می کند.
- این آرگومان مشخص می‌کند که فایل با چه حالتی باز شود.  
**حالت‌های اصلی:**

#### حالت‌های پایه:
- `'r'`: فقط خواندن (پیش‌فرض)
- `'w'`: فقط نوشتن (محتوای قبلی پاک می‌شود)
- `'a'`: فقط نوشتن در انتهای فایل (الحاق)
- `'x'`: ایجاد انحصاری (خطا می‌دهد اگر فایل وجود داشته باشد)

#### حالت‌های ترکیبی:
- `'r+'`: خواندن و نوشتن
- `'w+'`: خواندن و نوشتن (محتوای قبلی پاک می‌شود)
- `'a+'`: خواندن و نوشتن در انتهای فایل

#### حالت‌های باینری:
- `'b'`: حالت باینری (برای فایل‌های غیرمتنی)
- `'t'`: حالت متنی (پیش‌فرض)

ترکیب حالت‌ها:
```py
'rb'  # خواندن باینری
'wb'  # نوشتن باینری
'rt'  # خواندن متنی (معادل 'r')
'wt'  # نوشتن متنی (معادل 'w')
```

### 3. پارامتر `buffering`
سیاست بافرینگ را تعیین می‌کند:
- `0`: غیرفعال کردن بافرینگ (فقط در حالت باینری)
- `1`: بافرینگ خطی (در حالت متنی)
- عدد صحیح بزرگتر از ۱: اندازه بافر به بایت
- عدد منفی: استفاده از مقدار پیش‌فرض سیستم

#### **Buffering و انواع ان**
-Buffering در پایتون به معنای استفاده از یک حافظه موقت (بافر) برای ذخیره‌سازی داده‌ها قبل از نوشتن روی دیسک یا خواندن از دیسک است. این مکانیسم برای بهبود کارایی و کاهش تعداد دسترسی‌های مستقیم به دیسک (که کند است) استفاده می‌شود.

##### **انواع Buffering :**
1. بدون بافرینگ `(buffering=0):`
داده‌ها بلافاصله و بدون استفاده از بافر نوشته یا خوانده می‌شوند.
فقط در حالت باینری `('b')` قابل استفاده است.

2. بافرینگ خطی `(buffering=1):`
در حالت متنی `('t')`، داده‌ها به صورت خط به خط بافر می‌شوند.
در حالت باینری، معادل buffering با اندازه ۱ بایت است.

3. بافرینگ با اندازه مشخص `(buffering > 1):`
داده‌ها در بلوک‌هایی با اندازه مشخص بافر می‌شوند.
برای بهبود عملکرد در عملیات‌های خواندن و نوشتن زیاد مفید است.

### 4. پارامتر `encoding` 
- این آرگومان مشخص می‌کند که از چه *encoding (رمزگذاری)* برای فایل متنی استفاده شود. پیش‌فرض آن بستگی به سیستم عامل دارد (معمولاً `'utf-8'`).

کدگذاری متن فایل را مشخص می‌کند:

- مثال:
  ```python
  file = open('data.txt', encoding='utf-8')
  ```

### 5. پارامتر `errors`
- این آرگومان مشخص می‌کند که چگونه خطاهای **encoding/decoding** مدیریت شوند. 
رفتار در مواجهه با خطاهای کدگذاری:
- `'strict'`: ایجاد خطا (پیش‌فرض)
- `'ignore'`: نادیده گرفتن خطاها
- `'replace'`: جایگزینی با علامت ؟
- `'backslashreplace'`: جایگزینی با توالی پشت‌شیوه

### 6. پارامتر `newline` 
مدیریت کاراکترهای خط جدید:
- `None`: تبدیل خودکار خطوط جدید
- `''`: عدم تبدیل خطوط جدید
- `'\n'`, `'\r'`, `'\r\n'`: استفاده از کاراکتر مشخص شده

### 7. پارامتر `closefd` 
- اگر `False` باشد، descriptor فایل پس از بسته شدن باز می‌ماند

### 8. پارامتر `opener` 
- این آرگومان یک تابع سفارشی برای باز کردن فایل ارائه می‌دهد. تابع باید یک file descriptor بازگرداند.

تابع سفارشی برای باز کردن فایل:
```python
def custom_opener(file, flags):
    return os.open(file, flags, 0o644)

file = open('data.txt', opener=custom_opener)
```

## روش‌های کار با فایل باز شده

### متدهای اصلی:
1. `read(size=-1)`: خواندن محتوا
2. `readline(size=-1)`: خواندن یک خط
3. `readlines(hint=-1)`: خواندن تمام خطوط
4. `write(s)`: نوشتن رشته
5. `writelines(lines)`: نوشتن چندین خط
6. `seek(offset, whence=0)`: تغییر موقعیت
7. `tell()`: گزارش موقعیت فعلی
8. `flush()`: تخلیه بافر
9. `close()`: بستن فایل

## بهترین روش استفاده (با context manager)

همیشه از بلوک `with` استفاده کنید:

```python
with open('file.txt', 'r', encoding='utf-8') as f:
    content = f.read()
    # پردازش محتوا
# فایل به صورت خودکار بسته می‌شود
```

## مثال‌های تابع open

### 1. خواندن فایل:
```python
with open('data.txt', 'r') as file:
    for line in file:
        print(line.strip())
```

### 2. نوشتن در فایل:
```python
with open('output.txt', 'w') as file:
    file.write('متن جدید\n')
    file.writelines(['خط اول\n', 'خط دوم\n'])
```

### 3. کار با فایل‌های باینری:
```python
with open('image.jpg', 'rb') as file:
    data = file.read()
```

### 4. مدیریت خطاها:
```python
try:
    with open('data.txt', 'r', encoding='utf-8') as file:
        content = file.read()
except FileNotFoundError:
    print("فایل وجود ندارد!")
except PermissionError:
    print("دسترسی مجاز نیست!")
except UnicodeDecodeError:
    print("مشکل در کدگذاری فایل!")
```

## نکات مهم و بهترین روش‌ها

1. همیشه از `with` استفاده کنید تا فایل به صورت خودکار بسته شود
2. برای فایل‌های بزرگ، به جای `read()` از خواندن خط به خط استفاده کنید
3. برای متن‌های فارسی حتماً encoding را روی `'utf-8'` تنظیم کنید
4. برای فایل‌های غیرمتنی از حالت باینری (`'b'`) استفاده کنید
5. قبل از کار با فایل، از وجود آن مطمئن شوید
6. پس از اتمام کار با فایل، آن را ببندید (اگر از `with` استفاده نمی‌کنید)


# متدهای خواندن و نوشتن

در پایتون، متدهای خواندن و نوشتن (Read/Write Methods) برای کار با فایل‌ها و جریان‌های داده استفاده می‌شوند. این متدها به شما امکان می‌دهند داده‌ها را   مختلف بخوانید یا در آنها بنویسید. 
در پایتون، متدهای مختلفی برای خواندن فایل‌ها وجود دارد که هر کدام کاربرد خاصی دارند. 

## ۱. متدهای خواندن فایل

### ۱.۱ `read(size=-1)`
- **کاربرد**: خواندن تمام یا بخشی از محتوای فایل
- **پارامترها**:
  - `size`: تعداد کاراکتر/بایت برای خواندن (اگر مشخص نشود یا -1 باشد، کل فایل خوانده می‌شود)
- **مثال**:
```python
with open('file.txt', 'r', encoding='utf-8') as f:
    content = f.read()  # خواندن تمام فایل
    first_100 = f.read(100)  # خواندن ۱۰۰ کاراکتر اول
```

### ۱.۲ `readline(size=-1)`
- **کاربرد**: خواندن یک خط از فایل
- **پارامترها**:
  - `size`: حداکثر تعداد کاراکتر برای خواندن
- **مثال**:
```python
with open('file.txt', 'r') as f:
    line1 = f.readline()  # خواندن خط اول
    line2 = f.readline()  # خواندن خط دوم
```

### ۱.۳ `readlines(hint=-1)`
- **کاربرد**: خواندن تمام خطوط به صورت لیست
- **پارامترها**:
  - `hint`: تعداد تقریبی بایت برای خواندن
- **مثال**:
```python
with open('file.txt', 'r') as f:
    lines = f.readlines()  # لیست تمام خطوط
    for line in lines:
        print(line.strip())
```

##  متد `readable()`

این متد یک مقدار بولین (True/False) برمی‌گرداند که نشان می‌دهد آیا فایل در حالت خواندنی باز شده است یا خیر.


```python
with open('data.txt', 'r') as f:
    if f.readable():
        content = f.read()
        print(content)
    else:
        print("فایل قابل خواندن نیست")
```

```python
try:
    f = open('important.txt', 'a+')
    if f.readable():
        data = f.read()
        # پردازش داده
    else:
        print("امکان خواندن از فایل وجود ندارد")
finally:
    f.close()
```

## 2. **متدهای اصلی نوشتن**

### 2.۱ `write(text)`
- **کاربرد**: نوشتن یک رشته به فایل
- **مثال**:
```python
with open('file.txt', 'w', encoding='utf-8') as f:
    f.write('این یک متن نمونه است\n')
    f.write('این خط دوم است')
```

### 2.۲ `writelines(lines)`
- **کاربرد**: نوشتن یک لیست از رشته‌ها به فایل
- **مثال**:
```python
lines = ['خط اول\n', 'خط دوم\n', 'خط سوم\n']
with open('file.txt', 'w', encoding='utf-8') as f:
    f.writelines(lines)
```

## 3. مدیریت بافر 

### 3.۱ `flush()`
- در پایتون برای اجباری کردن نوشتن داده‌های بافر شده به فایل از`flush()`استفاده می شود
-  پایتون به‌طور پیش‌فرض داده‌ها را در یک بافر (حافظه موقت) ذخیره می‌کند تا در زمان مناسب (مثلاً وقتی بافر پر شود یا فایل بسته شود) آن‌ها را به فایل اصلی منتقل کند.

- می‌توانید این داده‌های بافر شده را بلافاصله و بدون بستن فایل به فایل اصلی  flush() با استفاده از   منتقل کنید. این کار در مواقعی مفید است که می‌خواهید مطمئن شوید داده‌ها بلافاصله روی دیسک نوشته شده‌اند، حتی اگر فایل هنوز باز باشد.


- **کاربرد**: تخلیه بافر و نوشتن فوری داده‌ها روی دیسک
- **مثال**:
```python
f = open('important.txt', 'w', encoding='utf-8')
f.write('داده‌های مهم')
f.flush()  # اطمینان از نوشته شدن فوری
# ... عملیات دیگر ...
f.close()
```

### 3.۲ استفاده با `os.fsync()`
- در پایتون برای اجباری کردن نوشتن داده‌های بافر شده به دیسک استفاده می‌شود. این os.fsync() تابع اطمینان می‌دهد که تمام داده‌های بافر شده در حافظه (نه فقط در بافر سیستم عامل، بلکه در سطح 
سخت‌افزار) به‌طور فیزیکی روی دیسک نوشته شده‌اند.

- **کاربرد**: اطمینان از نوشته شدن داده‌ها روی دیسک فیزیکی
- **مثال**:
```python
import os

f = open('critical.txt', 'w', encoding='utf-8')
f.write('داده‌های حیاتی')
f.flush()
os.fsync(f.fileno())  # همگام‌سازی با دیسک
f.close()
```
### 3.3 نوشتن کردن فایل باینیری/غیراسکی 
برای نوشتن یک رشته از حالت `باینری` به روش زیر عمل می کنم
```python
f = open("note.text" , "ab")
s = b"ali reza"
print(f.write(s))
```
اگر در رشته یک کارکتر `غیر اسکی` داشته باشیم باید از روش زیر عمل کنیم
```python
f = open("note.text" , "ab")
s = bytes("ali reza", "utf-8")
print(f.write(s))
```

##  متد `writable()`

این متد یک مقدار بولین (`True`/`False`) برمی‌گرداند که نشان می‌دهد آیا فایل در حالت قابل نوشتن باز شده است یا خیر.

**مثال:**
```python
with open('data.txt', 'a') as f:
    if f.writable():
        f.write('متن جدید\n')
    else:
        print("امکان نوشتن در فایل وجود ندارد")
```
```python
f = open('important.txt', 'r+')
if f.writable():
  f.write('آپدیت جدید')
else:
  print("فایل قابل نوشتن نیست")
f.close()
```

## نکات مهم:

1. این متد فقط وضعیت فایل را بررسی می‌کند و وجود فایل یا دسترسی به آن را تأیید نمی‌کند.

3. این متد جایگزین مدیریت خطا (try-except) نیست. حتی اگر `writable()` True برگرداند، ممکن است در عمل نوشتن با خطا مواجه شوید.

4. برای فایل‌های باینری نیز کار می‌کند:
```python
with open('data.bin', 'wb') as f:
    print(f.writable())  # True
```

5. تفاوت بین `writable()` و `writeable()`:
- هر دو فرم صحیح هستند و کار یکسانی انجام می‌دهند
- `writable()` فرم ترجیحی در پایتون است


---
# تغیر موقعیت اشاره گر

متد `seek()` برای تغییر موقعیت اشاره‌گر فایل در پایتون استفاده می‌شود و کنترل دقیقی بر محل خواندن/نوشتن در فایل ارائه می‌دهد.

## نحو استفاده از `seek()`

```python
file.seek(offset, whence)
```

### پارامترها:
- **offset**: تعداد بایت برای جابجایی (مثبت یا منفی)
- **whence** (اختیاری): مبدأ محاسبه (پیش‌فرض 0)
  - `0`: ابتدای فایل
  - `1`: موقعیت فعلی
  - `2`: انتهای فایل

## مثال‌:

### مثال ۱: جابجایی مطلق (از ابتدای فایل)
```python
with open('example.txt', 'r+') as f:
    f.write('Hello World!')
    f.seek(6)  # رفتن به بایت ششم (پس از 'Hello ')
    print(f.read())  # خروجی: 'World!'
```

### مثال ۲: جابجایی نسبی (از موقعیت فعلی)
```python
with open('data.bin', 'rb+') as f:
    f.seek(10)
    f.write(b'ABCD')
    f.seek(-4, 1)  # 4 بایت به عقب از موقعیت فعلی
    print(f.read(4))  # خروجی: b'ABCD'
```

### مثال ۳: جابجایی از انتهای فایل
```python
with open('log.txt', 'a+') as f:
    f.seek(-20, 2)  # 20 بایت قبل از انتهای فایل
    last_20_bytes = f.read()
```

### مثال4: خواندن فایل معکوس
```python
with open('reverse.txt', 'rb') as f:
    f.seek(0, 2)  # رفتن به انتهای فایل
    while f.tell() > 0:
        f.seek(-1, 1)
        print(f.read(1).decode(), end='')
        f.seek(-1, 1)
```

### مثال5: ویرایش بخشی از فایل
```python
with open('database.db', 'r+b') as f:
    f.seek(100)  # رفتن به موقعیت 100
    f.write(b'NEW DATA')  # بازنویسی 8 بایت
```

### مثال6: خواندن ساختارهای ثابت
```python
record_size = 50
record_num = 3
with open('records.dat', 'rb') as f:
    f.seek(record_num * record_size)  # رفتن به رکورد سوم
    record = f.read(record_size)
```

## نکته:

1. **حالت باینری**: برای جابجایی دقیق (مخصوصاً با مقادیر منفی) باید فایل را در حالت باینری (`'b'`) باز کنید

2. **متد `tell()`**: برای فهمیدن موقعیت فعلی استفاده می‌شود
   ```python
   pos = f.tell()  # موقعیت فعلی
   ```

3. **فایل‌های متنی**: در فایل‌های متنی (بدون 'b')، جابجایی فقط نسبت به ابتدای فایل کار می‌کند

4. **خطاها**: جابجایی خارج از محدوده فایل ممکن است باعث خطا شود

5. **کارایی**: استفاده از `seek()` برای دسترسی تصادفی بهینه‌تر از خواندن کل فایل است

# دستور `with/as` و مدیریت زمینه (Context Manager)

دستور `with` در پایتون یک روش امن و کارآمد برای مدیریت منابع مانند فایل‌ها، اتصالات شبکه و سایر منابع سیستمی ارائه می‌دهد. این دستور از مفهوم **مدیریت زمینه** (Context Management) استفاده می‌کند.

## ساختار پایه

```python
with expression [as variable]:
    # بلوک کد
```

## مثال کاربردی با فایل‌ها

```python
# روش سنتی (بدون with)
file = open('example.txt', 'r')
try:
    content = file.read()
finally:
    file.close()

# روش مدرن (با with)
with open('example.txt', 'r') as file:
    content = file.read()
# فایل به صورت خودکار بسته می‌شود
```

## مزایای استفاده از `with`

1. **مدیریت خودکار منابع**: بستن خودکار فایل‌ها و آزادسازی منابع
2. **کاهش خطاها**: جلوگیری از فراموشی بستن منابع
3. **خوانایی بهتر**: کد تمیزتر و قابل فهم‌تر
4. **مدیریت استثناها**: کنترل خودکار خطاها در بلوک with

## نحوه کار Context Manager

یک Context Manager باید دو متد داشته باشد:
1. `__enter__()`: هنگام ورود به بلوک `with` اجرا می‌شود
2. `__exit__()`: هنگام خروج از بلوک `with` اجرا می‌شود

### مثال پیاده‌سازی یک Context Manager سفارشی

```python
class Timer:
    def __enter__(self):
        import time
        self.start = time.time()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        self.end = time.time()
        print(f"زمان اجرا: {self.end - self.start:.2f} ثانیه")

# استفاده
with Timer() as t:
    # انجام عملیات زمان‌بر
    sum(range(1000000))
```

##  مدیریت چندین منبع

```python
with open('input.txt', 'r') as input_file, open('output.txt', 'w') as output_file:
    for line in input_file:
        output_file.write(line.upper())
```

## نکات مهم

1. **متغیر پس از `as`**: فقط در بلوک `with` در دسترس است
2. **استثناها**: `__exit__()` حتی در صورت بروز خطا نیز اجرا می‌شود
3. **قابلیت ترکیب**: می‌توان چندین Context Manager را با هم ترکیب کرد
4. **کارایی**: استفاده از `with` بار اضافی به کد تحمیل نمی‌کند

---

# کار با فایل جیسون - (json)
- ***json*** مخفف ***JavaScript Object Notation*** است
- JSON یک فرمت متنی است که برای نمایش اشیاء داده‌ای استفاده می‌شود.

 ساختار اصلی آن شامل جفت‌های کلید-مقدار است که در آن کلیدها (key) معمولاً رشته‌هایی هستند که در داخل علامت نقل قول دوتایی ("") قرار می‌گیرند و مقادیر (value) می‌توانند انواع مختلفی از داده‌ها مانند رشته، عدد، بولی، آرایه یا حتی اشیاء JSON دیگر را شامل شوند. 
## تبدیل جیسون به پایتون
  1. **loads**

  یک رشته جسون را به فرمت پایتونی پبدیل می کند
```py 
  json_data = '''
{
    "name": "علی",
    "age": 30,
    "city": "تهران"
}
'''

python_data = json.loads(json_data)
print(python_data["name"])  # خروجی: علی
```
 1. **load**

  یک فایل جیسون را به فرمت پایتونی تبدیل می کند
```py
with open('data.json', 'r', encoding='utf-8') as f:
    data = json.load(f)
    print(data)
```
```py
import json

with open("file.json", "r") as jf:
  s = json.load(jf)

print(s)
print(type(s))
```
##  تبدیل پایتون به جیسون
1. **dumps**

یک رشته پایتونی را به فرمت جیسون تبدیل می کند
```py
import json

data = {
    "name": "علی",
    "age": 30,
    "city": "تهران",
    "skills": ["Python", "Django", "JavaScript"]
}

json_string = json.dumps(data, ensure_ascii=False, indent=4)
print(json_string)
```
1. **dump**

یک فایل پایتونی را به فرمت جیسون تبدیل می کند
```py
with open('data.json', 'w', encoding='utf-8') as f:
    json.dump(data, f, ensure_ascii=False, indent=4)
```
```py
d = {"c":10, "x":16}
with open("file.json", "w") as jf:
json.dump(None, jf)
```
## دندانه گذاری
ما در پایتون می توانیم با استفاده از دندانه گذاری شکل و فرمت زیبا تری به فایل json  خود بدهیم
### 1. **indent**
- برای دندانه گذاری از `indent` استفاده می کنیم
- استفاده از پارامتر `indent` در `json.dump()` و `json.dumps()`
```py 
import json
d = {"name":"alireza",
    "lastname":"hosinzadeh",
    "age":23,
    "marks":{"amar":[12, 20,18], "elctronic":[10, 15, 18]},
    "lesson":["anatomy", "mogadme", "elctronic"]
    }

with open("myfile.json", "w") as jf:
  json.dump(d, jf, indect=2)
```
### 2. **sort_keys**
- برای مرتب کردن مقدار کلید ها بر اساس حروف الفبا انجام می دهد
**sort_keys** با مقادی ***True*** و ***False*** کار می کند
```py 
import json
d = {"name":"alireza",
    "lastname":"hosinzadeh",
    "age":23,
    "marks":{"amar":[12, 20,18], "elctronic":[10, 15, 18]},
    "lesson":["anatomy", "mogadme", "elctronic"]
    }

with open("myfile.json", "w") as jf:
  json.dump(d, jf, indect=2, sort_keys= True)
```
### 3. **separators**
- یک جدا کننده است که در پارامتر `separators` در `json.dumps()` کار میکند 
- یک تاپل با دو مقدار:
  - جداکننده بین آیتم‌ها (معمولاً ,) 
  - جداکننده بین کلید و مقدار (معمولاً :)
```py 
import json
d = {"name":"alireza",
    "lastname":"hosinzadeh",
    "age":23,
    "marks":{"amar":[12, 20,18], "elctronic":[10, 15, 18]},
    "lesson":["anatomy", "mogadme", "elctronic"]
    }

with open("myfile.json", "w") as jf:
  json.dump(d, jf, indect=2, sort_keys= True, separators(",", ":"))
```
## نکته
1. در برخی از مواقع به تبدیل **جیسون** به **پایتون** `deserialize` می گویند
2. در برخی از مواقع به تبدیل **پایتون** به **جیسون** `serialize` می گویند

---

# کار با فایل - csv
- ***CSV*** مخفف ***Comma-Separated Values***

فایل‌های CSV فایل‌هایی بسیار پرکاربرد برای ذخیره‌سازی داده‌های جدولی و ساختاریافته هستند.

این فایل‌ها یک فرمت استاندارد برای قالب‌بندی محتوای متنی بوده و معمولاً برای داده‌هایی که دارای سطر و ستون هستند، استفاده می‌شوند.
 
در این فایل‌ها، مقادیر با **کاما** از هم جدا می‌شوند. هر **سطر** نشان‌دهنده یک **موجودیت** و هر **ستون** نشان‌دهنده یک ویژگی یا **فیچر** از آن موجودیت است.

معمولاً اسامی ویژگی‌ها در سطر اول فایل CSV نوشته می‌شوند.


## **1.خواندن از فایل‌های CSV**

برای خواندن داده‌ها از یک فایل CSV، دو متد اصلی وجود دارد: `csv.reader` و `csv.DictReader`.

### **الف) csv.reader:**
خواندن سطرها به عنوان لیست

- این متد یک شیء خواننده (reader object) ایجاد می‌کند که مانند یک `iterator` عمل می‌کند.
-   **ایجاد شیء خواندن**:
```python
import csv
with open('iris.csv', 'r') as cf:
  data = csv.reader(cf)
```

**نکته**: سطر اول معمولاً شامل `اسامی فیچرها` یا `ویژگی‌ها` است.

**پیمایش و خواندن تمام سطرها**: می‌توانید با یک حلقه `for` تمام سطرها را پیمایش کنید. هر سطر به عنوان یک `list` از رشته‌ها خوانده می‌شود.
```python
import csv
with open('iris.csv', 'r') as cf:
for line in data:
  print(line)
#این حلقه هر سطر را به صورت یک لیست چاپ می‌کند.
```
```py
import csv

with open("file.csv") as cf:
data = csv.reader(cf)
for line in data:
  print(line[0])

#2

import csv

with open("file.csv") as cf:
  data = csv.reader(cf)
  for line in data:
    print(line[0], "---", line[1])
```

-   **دسترسی به ستون‌های خاص**: از آنجایی که هر سطر به شکل لیست خوانده می‌شود، می‌توانید با استفاده از ایندکس به مقادیر ستون‌های خاص دسترسی پیدا کنید.
```python
# چاپ ستون اول و دوم (ایندکس 0 و 1)
for line in data:
  print([0], [1])
```


### **ب) csv.DictReader**
خواندن سطرها به عنوان دیکشنری

- این متد سطرها را به شکل `dictionary` می‌خواند. کلیدهای دیکشنری نام ستون‌ها (از سطر اول فایل) و مقادیر، داده‌های هر سطر هستند.
- 
**ایجاد شیء خواننده دیکشنری**:

**پیمایش و خواندن سطرها**:
```python
# فرض کنید data شیء DictReader ما است
for line in data:
  print(line)
```
هر سطر به صورت یک دیکشنری چاپ می‌شود که نام ستون‌ها (فیچرها) کلید و مقادیر سطرها، مقادیر دیکشنری هستند.

```py
import csv

with open("file.csv") as cf:
  data = csv.DictReader(cf)
  for line in data:
    print(line)

#2

import csv

with open("file.csv") as cf:
  data = csv.DictReader(cf)
  for line in data:
    print(line["مقادیر ان کلید یا ستون را نشان می دهد"])
```

**دسترسی به ستون‌های خاص با نام (کلید)**: 

می‌توانید با استفاده از نام ستون به مقادیر دسترسی پیدا کنید.
```python
# چاپ مقدار ستون 'sepal_length'
for line in data:
  print(line['sepal_length'])
```

*توضیح*: `line['sepal_length']` مقدار ستون `sepal_length` را در آن سطر برمی‌گرداند.

## **2. نوشتن در فایل‌های CSV**

برای نوشتن داده‌ها در یک فایل CSV، از شیء `csv.writer` و متدهای `writerow()` و `writerows()` استفاده می‌شود.


### **الف)  writerow( ):**
`نوشتن هدر (سطر اول)`
-   این متد یک لیست به عنوان ورودی می‌گیرد و عناصر آن لیست را به عنوان یک سطر در فایل CSV می‌نویسد.
- این سطر را به عنوان هدر فایل CSV می‌نویسد (مثلاً: `ID,Name,LastName,Age`).


```python
# فرض کنید writer شیء نویسنده ما است
writer.writerow(['ID', 'Name', 'LastName', 'Age'])
```
```py
import csv
with open('students.csv', 'w', newline='', encoding='utf-8') as file:
writer = csv.writer(file)
 
# نوشتن هدر
writer.writerow(['شماره دانشجویی', 'نام', 'نام خانوادگی', 'نمره'])
  
# نوشتن یک سطر داده
writer.writerow([1001, 'علی', 'رضایی', 19.5])
```


### **ب) writerows( ):**
- writerows() یک متد از شی csv.writer است که برای نوشتن چندین سطر به صورت یکجا در فایل CSV استفاده می‌شود.
-   این متد یک لیست تو در تو (لیستی از لیست‌ها) به عنوان ورودی می‌گیرد. هر لیست داخلی به عنوان یک سطر جداگانه در فایل CSV نوشته می‌شود.

```python
import csv

data = [
[1, "علی", "رضایی", 25],
[2, "مریم", "محمدی", 30],
[3, "رضا", "کریمی", 22]
      ]

with open("students.csv", "w", newline='', encoding='utf-8') as file:
  writer = csv.writer(file)
  writer.writerow(["ID", "نام", "نام خانوادگی", "سن"])  # نوشتن هدر
  writer.writerows(data)  # نوشتن تمام داده‌ها
```
## تفاوت writerow( ) و writerows( ) :
- `writerow():` برای نوشتن **یک سطر** (یک لیست)
- `writerows():` برای نوشتن **چندین سطر** (لیست‌های تو در تو)

```py
import csv

with open("my,csv", "w",newline="") as cf:
  writer = csv.writer(cf)
  writer.writerow(["id", "name", "lastname",  "age"])
  data = [["1","ali","reza",13],
         ["2"," hana","tagizade",23],
         ["3"," masome","gahve dost",56],
         ]
  writer.writerows(data)
```
---
# شی گرای
1. همه چیز در پایتون یک شی است
2. هر شی حداقل باید نمونه ای از یک کلاس باشد
3. یک متغیر, یک ارجاع به شی است
4. هر کلاسی خود یک شی از کلاس(type) است و همه کلاس ها از کلاسی به اسم (object) ارث بری می کنند
5. در ساختار جدید پایتون , مفهوم کلاس بری برابر مفهوم(type) در نظر گرفته شده است

- در پایتون، **همه چیز یک شیء (Object) است**.
## ایجاد کلاس
برای ایجاد کلاس مانند تابع عمل می کنیم و به جای کلمه (def) از  (class) استفاده می کنیم

```py
class name:
  pass
# این کلاس ساده ترین نوع کلاس است که هیچ ساختار یا رفتار مشخصی ندارد
```
در شی گرای برای ایجاد کلاس لازم نیست از ***پرانتز ( )*** استفاده کنید.

زمانی از ***پرانتز ( )*** استفاده می کنیم که بخواهیم کلاس ما `ارث بری` داشته باشد

- ما اگر در توابع در بدنه تابع از دستور pass  استفاده می کیردیم تابع کاربرد خواصی نداشت 
اما در کلاس به این صورت نیست


## ایجاد شیء

یک **شیء**، **نمونه‌ای** (Instance) از یک *کلاس* است. کلاس یک طرح کلی است و اشیاء نمونه‌های واقعی از آن طرح هستند. هر شیء یک موجودیت مستقل در حافظه است.

- **نحوه ایجاد شیء**: برای ایجاد یک شیء از کلاس، نام کلاس را می‌نویسیم و **پرانتزها** را جلوی آن قرار می‌دهیم. این کار به معنای "نمونه‌سازی" (Instantiate) است.
- **: اهمیت پرانتزها**
  -   اگر پرانتزها را نگذارید، به جای ایجاد یک شیء جدید، فقط یک **ارجاع** (Reference) به خود کلاس ایجاد کرده‌اید. در این صورت، متغیر جدیدی که تعریف کرده‌اید، دقیقاً به خود کلاس اشاره می‌کند و نه به یک نمونه از آن.
  -   برای **ایجاد شیء** حتماً باید پرانتزها را بگذارید.

```python
class point:
    pass

p1 = Point() # p1 یک شیء از کلاس Point است
p2 = Point() # p2 نیز یک شیء از کلاس Point است

# p1 و p2 دو شیء کاملاً مستقل با آدرس‌های حافظه متفاوت هستند
print(p1) 
print(p2) 
```

## اضافه کردن اتریبیوت

**اتریبیوت‌ها**، **ویژگی‌ها** یا **صفاتی** هستند که یک شیء را توصیف می‌کنند (مانند رنگ، وزن، ابعاد).

- **نحوه اضافه کردن**: می‌توانید اتریبیوت‌ها را **پس از ایجاد شیء** و حتی بدون تعریف قبلی در کلاس، با استفاده از `.` (دات) و سپس نام دلخواه اتریبیوت، به شیء اضافه کنید.

- **مقداردهی**: با استفاده از عملگر `=` (مساوی)، می‌توان به اتریبیوت‌ها مقدار دلخواه داد.
```
<object>.<attribute> = <value>
مقدار دلخواه = اتربیوت.شیء 
p1.x = 3
```
- **خواندن مقدار اتریبیوت**: برای دسترسی به مقدار یک اتریبیوت، کافی است نام شیء و سپس `.` و نام اتریبیوت را بنویسید.
```
print(تربیوت.شیء)
```
- **اختصاصی بودن اتریبیوت‌ها**: اتریبیوت‌هایی که به این روش اضافه می‌شوند، **فقط به همان شیء خاص** تعلق دارند و روی سایر اشیاء از همان کلاس **تأثیری نمی‌گذارند**.

```python
class point:
    pass

p1 = point()

p1.x = 1
p1.y = 3
print(10 * "-",'p1',10 * "-")
print(p1.x)
print(p1.y)
print(10 * "-",'p1.new',10 * "-")
p1.x = 7
p1.y = 2
print(p1.x)
print(p1.y)

```
**نکته**: مقادیر اتریبیوت‌ها می‌توانند از هر نوعی باشند: اعداد، رشته‌ها، توابع یا حتی اشیاء دیگر.

## اضافه کردن متد 

**متدها**، توابعی هستند که درون یک کلاس تعریف می‌شوند و **رفتارها** یا **عملکردهای** یک شیء را مشخص می‌کنند.

- **تعریف متد**: متدها نیز با کلمه کلیدی `def` تعریف می‌شوند، درست مانند توابع عادی.
- **پارامتر `self`**: **تنها تفاوت اصلی** متدها با توابع معمولی، وجود **`self` به عنوان اولین پارامتر** در تعریف متد است.
    - **`self` به "خود شیء" اشاره می‌کند** که متد را فراخوانی کرده است.
    - این یک **قرارداد** بین برنامه‌نویسان پایتون است که اولین پارامتر را `self` بنامند، هرچند می‌توان نام دیگری برای آن انتخاب کرد (**اما توصیه نمی‌شود**).
    - با استفاده از `self`، متد می‌تواند به **اتریبیوت‌های اختصاصی** شیء خود (مانند `self.x` و `self.y`) دسترسی پیدا کرده و آن‌ها را تغییر دهد.
    - Pycharm معمولاً `self` را به صورت خودکار اضافه می‌کند.

```python
class point:
    def reset(self):
        self.x = 0
        self.y = 0
        

p1 = point()

p1.x = 1
p1.y = 2

print(10 * "-",'p1',10 * "-")
print("x:",p1.x)
print("y:",p1.y)

print(10 * "-",'p1',10 * "-")
p1.reset()
print("x:",p1.x)
print("y:",p1.y)


```

## فراخوانی متدها

متدها را می‌توان به دو روش فراخوانی کرد:

### 1. فراخوانی متد عادی (Instance Method)
- نیاز به شیء دارد `object.method()`.

- پارامتر self دریافت می‌کند (ارجاع به خود شیء).

```py
class point:
    def reset(self):
        self.x = 0
        self.y = 0

p1 = point()

p1.x = 1
p1.y =2

print(10 * "-",'p1.reset',10 * "-")
p1.reset()
print("x =", p1.x,"y =", p1.y)
```
### 2. فراخوانی متد کلاس (Class Method)
- کار با متغیرهای کلاس `Class.method()`.

- پارامتر class دریافت می‌کند (ارجاع به کلاس).
```py
class point:
    def reset(self):
        self.x = 0
        self.y = 0

p2 = point()

p2.x = 3
p2.y = 4

print(10 * "-",'p2.reset',10 * "-")
point.reset(p2)
print("x =", p2.x,"y =", p2.y)
```
**نکته مهم**: اگر پارامتر `self` در تعریف متد وجود نداشته باشد، هنگام فراخوانی متد، پایتون نمی‌داند روی کدام شیء باید عمل کند و خطا می‌دهد.

## مثال تکمیلی
در این مثال ما سه فراخانی متتد داریم
1. rest
2. move
3. distance

```py
from math import hypot

class point:
    def move(self, x:float ,y:float )->None:
        self.x = x
        self.y = y
    def rest(self):
        self.move(0, 0)
    def distance(self, other:"point")->float:
        return hypot(self.x - other.x, self.y - other.y)
    
p1 = point()
p2 = point()

p1.rest()
print(p1.x, p1.y)
p2.move(3, 4)
print(p2.x, p2.y)

print(p1.distance(p2))
```
# مقدار دهی اولیه شی
ما در مقدار دهی اولیه می خواهیم هنگامی که (object) ساختیم یک مقدار دیفالت از قبل به ان (object) ما داده بشود و
 ارور ` object has no attribute ` ندهد 
و اگر کابر خواست یک مقدار دلخواه به ان  (object) بدهد

**برای مقدار دهی از چند روش می توان عمل کرد**
1. هنگامی که یک (object) جدید میسازیم یک متدی را از قبل صدا بزند و مقدار ان متد را در (object) ما قرار بدهد 
2. هنگام ساخت (object) حتما باید مقدار دهی شود

## Constructor
به متدی اشاره دارد که به محض ساخت یک آبجکت از روی کلاسی، به صورت خودکار فراخوانی می‌شود.

این متد هنگام ساخته شدن (object) به صورت خودکار فراخوانی میشود و وظیفه اولیه مقدار دهی اولیه را انجام می دهد.
- پایتون برای انکه بتوان مقدار دهی اولیه را انجام دهداز دو متد به نام های 
1. --new--
   - .وظیفه ایجاد کردن را بر عهده  دارد 
---
2. --int--
   - وظیفه مقدار دهی اولیه را بر عهده  دارد

 این دو متتد با کمک همدیگه وظیفه مقدار دهی اولی را بر عهده  داردند

**نکته:** هر (object) که ایجاد کنیم ان دو متتد را در خود دادر

**نکته 2:** دستور (--new--) وظیفه ساخت  (object) را بر اهده دارد و بعد از ساخت  (object) و قبل از قرار دادن ان در (object)  متد (--int--) را صدا میزند .

- صدا زدن(--int--)به این دلیل است که یک سری اتربیوت و صفاتی که  کلاس ما دارد را مقدار دهی کند

```py
class point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
p1 = point(10, 15)
print(p1.x)
print(p1.y)
```

---
# مستند سازی کلاس و ابزار doctest و mypy
Decorator = مستند سازی کلاس
--
همانطور که توابع نیاز به مستندسازی دارند، **کلاس‌ها و متدهای آن‌ها نیز باید مستندسازی شوند**.

مانند سر فصل  در این بخش هم برای مستند سازی از 3 تا `' ' '` (کوتیشن) یا `" " "` (دابل کوتیشن) استفاده می کنیم.

- نحوه استفاده (Decorator) در کلاس
  1. هدف از نوشتن کلاس را می نویسیم
  
  - برای هر متد، در خط اول خلاصه‌ای از کار آن تابع یا متد نوشته می‌شود. سپس **پارامترها** و در صورت وجود، **مقادیر بازگشتی (Return Values)** مشخص می‌شوند.
    - *توجه داشته باشید که اگر متد مقداری را بازنگرداند (مثل `None`)، نیازی به نوشتن بخش `Returns` نیست.*

  1. یک توضیح مختصر در باره کلاس میدهیم
  2. یک مثال نیز از دستورات میزنیم

  - برای زدن مثال در (Decorator) ما از حالت تعاملی `<<<` استفاده می کنیم

  4. اتربیوت ها و متتد ها را می نویسیم

```py
class Calculator:
    """
    یک ماشین حساب ساده که عملیات پایه ریاضی را انجام می‌دهد.
    
    Attributes:
        version (str): نسخه فعلی ماشین حساب
        manufacturer (str): نام سازنده
    
    Methods:
        add(a, b): جمع دو عدد
        subtract(a, b): تفریق دو عدد
    """
    
    version = "1.0"
    manufacturer = "ACME Corp"
    
    def add(self, a: float, b: float) -> float:
        """
        جمع دو عدد را محاسبه می‌کند.
        
        Args:
            a (float): عدد اول
            b (float): عدد دوم
            
        Returns:
            float: نتیجه جمع a و b
            
        Examples:
            >>> calc = Calculator()
            >>> calc.add(2, 3)
            5.0
            >>> calc.add(-1, 1)
            0.0
        """
        return float(a + b)
    
    def subtract(self, a: float, b: float) -> float:
        """تفریق دو عدد (a - b)"""
        return a - b
```
## مشاهده (Decorator) 
برای ان که ما (Decorator) یک کلاس را مشاهده کنیم چند روش وجود دارد :
1. **__ doc __**

می‌توانید با استفاده از صفت `__doc__`، داک‌استرینگ مربوط به یک کلاس یا متد را مشاهده کنید.

 این روش روش معمول و مناسبی **نیست**.
  ```py
  print(point.__doc__)
```
**محدودیت:** این روش فقط داک‌استرینگ مربوط به همان شیء (کلاس یا متد) را نشان می‌دهد و جزئیاتی مانند متدها، Attributeها و توضیحات آن‌ها را به صورت جامع نمایش نمی‌دهد.

1. **help**

**بهترین و کامل‌ترین راه برای مشاهده داک‌استرینگ‌ها و درک کامل یک کلاس**، استفاده از تابع `help()` است.

  **نکته:** از این دستور می توان برای تمامی متتد ها استفاده کرد
  ```py
print(help(point))
  ```
## doctest
- **هدف:** `doctest` به شما کمک می‌کند تا **مثال‌هایی که در داک‌استرینگ خود نوشته‌اید را تست کنید**. این ابزار مثال‌ها را اجرا کرده و نتایج آن‌ها را با نتایج مورد انتظار مقایسه می‌کند.
- **کاربرد:** اگر نتیجه مورد انتظار شما با نتیجه واقعی اجرای مثال‌ها مطابقت نداشته باشد، `doctest` به شما خطا می‌دهد. این کار به حفظ دقت و به‌روز بودن مثال‌های مستندات شما کمک می‌کند.
- **نحوه استفاده:**
    *   `doctest` یک ماژول داخلی پایتون است و نیازی به نصب ندارد.
    *   آن را در کد خود `import` کنید: `import doctest`.
    *   برای اجرای تست‌ها: `doctest.testmod()`.
- **مثال:** فرض کنید در داک‌استرینگ خود مثالی نوشته‌اید که انتظار دارید نتیجه `5.0` باشد، اما کد شما `0.0` برمی‌گرداند. `doctest` این ناهماهنگی را به شما گزارش می‌دهد.

```py
import doctest
doctest.testmod()
```

## mypy
- **هدف:** `mypy` یک ابزار **بررسی کننده تایپ (Type Checker)** است که **تایپ‌هینت‌ها (Type Hints) و انوتیشن‌ها (Annotations)** را در کد شما بررسی می‌کند.
- **کاربرد:** این ابزار اطمینان حاصل می‌کند که شما پارامترها و مقادیر بازگشتی را مطابق با انواع داده‌ای که در کد (با استفاده از Type Hints) مشخص کرده‌اید، ارسال و دریافت می‌کنید.
- **نحوه استفاده:**
    - ابتدا آن را نصب کنید: `pip install mypy`.
    -  سپس در ترمینال آن را روی فایل پایتون خود اجرا کنید: `mypy your_module.py`.
- **اهمیت:** در IDEهای پیشرفته مانند PyCharm، ممکن است Type Hintها به صورت خودکار بررسی شوند، اما `mypy` برای ویرایشگرهای کد ساده‌تر یا برای اجرای بررسی‌ها در خط فرمان (مانند فرآیند CI/CD) بسیار مفید است.
- **مثال:** اگر در `__init__` متد کلاس `Point`، پارامتر `x` را از نوع `float` تعریف کرده باشید اما به اشتباه یک `str` برای آن ارسال کنید، `mypy` این خطا را تشخیص داده و گزارش می‌کند.

---
# (در شی گرای)ماژول‌ها و کلاس‌ها

## سازماندهی کلاس‌ها در ماژول‌ها
-   بهتر است **کلاس‌ها در ماژول‌های جداگانه** و بر اساس کارکردشان نوشته شوند. این کار از شلوغی یک فایل با تعداد زیادی کلاس و پیاده‌سازی‌های مختلف جلوگیری می‌کند.
-   برای مثال، کلاس‌های مربوط به بازی نباید کنار کلاس‌های ریاضی یا پردازش هوش مصنوعی قرار بگیرند؛ هر کدام باید در ماژول‌های مجزا (و پکیج‌های جداگانه) باشند.
-   برای استفاده از کلاس‌ها، باید ماژول حاوی آن‌ها را **ایمپورت (import)** کرد. این کار می‌تواند به دو صورت انجام شود:
1. **ایمپورت کل ماژول**:
```py
import point
p1 = point.Point()
```

2. **ایمپورت مستقیم کلاس**:
```py
from point import Point
p1 = Point()
```

- **ایجاد آبجکت (Object Instantiation)**
  -   **روش معمول**: در اغلب مواقع، کلاس را ایمپورت می‌کنیم و هر جا که لازم باشد، چندین آبجکت متفاوت از آن ایجاد می‌کنیم. `دو آبجکت متفاوت خواهند بود`.
  
  -   **ایمپورت آبجکت ساخته شده (برای آبجکت‌های یگانه - Singleton)**: برای برخی کلاس‌ها (مانند اتصال به پایگاه داده) لازم است که فقط یک آبجکت از آن وجود داشته باشد. در این حالت، می‌توان آبجکت را **درون همان ماژول تعریف و ساخته** و سپس مستقیماً آن آبجکت را ایمپورت کرد.

***نکته :***  همگی به یک آبجکت اشاره خواهند کرد. آدرس حافظه‌ای آن‌ها یکسان خواهد بود.
```py 
from point import point 

p2 = point 
p1 = point
print(p1)
print(p2)
```

## مشکل ساخت آبجکت زمان‌بر در زمان ایمپورت و راه‌حل آن
-   **مشکل**: اگر ساخت یک آبجکت (مخصوصاً در حالت ایمپورت آبجکت یگانه) **زمان‌بر باشد** (مثلاً ۵، ۱۰ یا ۲۰ ثانیه)، این زمان‌بری **بلافاصله با ایمپورت شدن ماژول** اتفاق می‌افتد، حتی قبل از اینکه از آبجکت استفاده شود. این می‌تواند باعث کند شدن شروع برنامه شود.

**مثال:**
```python
from time import sleep

class Point:
  pass

# فرض کنید ساخت آبجکت زمانبر است
sleep(5) # این خط باعث تاخیر هنگام ایمپورت میشود
point = Point()
```

-   **راه‌حل (Lazy Initialization/Singleton Pattern با تابع)**: برای حل این مشکل، می‌توان ساخت آبجکت را به **یک تابع (function)** موکول کرد تا آبجکت فقط زمانی ساخته شود که نیاز داریم. این تابع معمولاً نامی مانند `get_point` خواهد داشت.
-   این تابع، وجود آبجکت را بررسی می‌کند و **اگر قبلاً ساخته نشده باشد، آن را می‌سازد و برمی‌گرداند**؛ در غیر این صورت، آبجکت موجود را برمی‌گرداند.
-   برای اینکه تابع بتواند یک متغیر گلوبال (مانند `point` برای نگهداری آبجکت) را دستخوش تغییر قرار دهد، باید از کلمه کلیدی **`global`** استفاده شود.
-   **مثال کد:**
```python
from time import sleep
from typing import Optional # برای راهنمای نوع

class Point:
# ... متدهای کلاس
pass

_point: Optional[Point] = None # متغیر گلوبال برای نگهداری آبجکت

def get_point() -> Point: # راهنمای نوع برای برگشتی تابع
  global _point # اشاره به متغیر گلوبال
  if _point is None: # یا if not _point - بررسی وجود آبجکت
      print("Creating point object...")
      sleep(5) # عملیات زمانبر ساخت آبجکت
      _point = Point() # ساخت آبجکت
  return _point # بازگرداندن آبجکت
```

-   با این روش، ایمپورت کردن ماژول سریع اتفاق می‌افتد و زمان‌بری تنها زمانی رخ می‌دهد که تابع `get_point` صدا زده شود.
-   فراخوانی چند باره `get_point` نیز همان **یک آبجکت یگانه** را برمی‌گرداند، به دلیل شرط `if _point is None:`. اگر این شرط حذف شود، هر بار فراخوانی تابع یک آبجکت جدید می‌سازد.

## **(Type Hinting / Annotations)**


-   یک فایل پایتون می‌تواند هم **به عنوان یک اسکریپت مستقل** (که مستقیماً اجرا می‌شود) و هم **به عنوان یک ماژول** (که توسط فایل‌های دیگر ایمپورت می‌شود) عمل کند.
-   **مشکل**: اگر کدهای اجرایی (مانند فراخوانی توابع یا پرینت) مستقیماً در بدنه اصلی یک فایل پایتون قرار داشته باشند، **هر بار که آن فایل به عنوان ماژول ایمپورت شود، آن کدها نیز اجرا خواهند شد**. این رفتار معمولاً نامطلوب است.
-   **متغیر خاص `__name__`**:در هر ماژول یک متغیر خاص به نام `__name__` دارد.
-   وقتی فایل پایتون **مستقیماً اجرا می‌شود**، مقدار `__name__` برابر با **`"__main__"`** است.
-   وقتی فایل پایتون **به عنوان ماژول ایمپورت می‌شود**، مقدار `__name__` برابر با **نام آن ماژول** (مثلاً `"point"` اگر فایل `point.py` باشد) است.
-   **راه‌حل**: برای کنترل اجرای کد، می‌توان کدهای اجرایی را درون یک **تابع (معمولاً با نام `main`)** قرار داد و سپس آن تابع را به صورت شرطی فراخوانی کرد.
-   **مثال کد**:
```python
# ... کلاس Point و تابع get_point

def main(): # تعریف تابع main
  # کدهایی که فقط هنگام اجرای مستقیم فایل باید اجرا شوند
  p1 = get_point() # مثال: ساخت آبجکت
  # p1.move(4, 9) # مثال: فراخوانی متد
  # print(p1.x, p1.y) # مثال: پرینت
    print("Running as script!") # مثال: پرینت

  if __name__ == "__main__": # شرط برای اجرای کد فقط در حالت اسکریپت
    main() # فراخوانی تابع main
```
-   با این ساختار، کدهای داخل `main` **فقط زمانی اجرا می‌شوند که فایل `point.py` مستقیماً اجرا شود** (چون `__name__` برابر `"__main__"` می‌شود).
-   اما اگر این فایل (point.py) توسط فایل دیگری (مثلاً `test.py`) ایمپورت شود، شرط `if __name__ == "__main__":` برقرار نخواهد بود (چون `__name__` برابر `"point"` می‌شود) و کدهای داخل `main` اجرا نخواهند شد، در نتیجه از اجرای ناخواسته جلوگیری می‌شود.

---

درود بر شما، حتماً. در ادامه خلاصه‌ای کامل و جامع از مبحث سطوح دسترسی و حالت‌های مختلف استفاده از آندرسکور در پایتون، به همراه نکات مهم و مثال‌های کاربردی، برای جزوه کلاس پایتون شما تهیه شده است:

---

**جزوه آموزش پایتون: مبحث سطوح دسترسی و کاربردهای آندرسکور**

در پایتون، بر خلاف برخی زبان‌های برنامه‌نویسی دیگر که سطوح دسترسی (Public, Private, Protected) را به صورت سفت و سخت پیاده‌سازی می‌کنند، این مفاهیم بیشتر به صورت **قراردادی** و با استفاده از علامت آندرسکور (`_`) مشخص می‌شوند. در این بخش، به بررسی ۵ حالت مختلف استفاده از آندرسکور می‌پردازیم که سه حالت اول آن در این مبحث پوشش داده شده است.

---
# سطح دسترسی و کاربرد های underscore 

## 1. استفاده از یک آندرسکور به تنهایی (`_`)

این حالت زمانی به کار می‌رود که **قصد ندارید از یک متغیر در ادامه کد استفاده کنید**، اما وجود آن از نظر گرامری یا ساختاری لازم است. که یک قرارداد بین برنامه نویس ان است.

- **کاربرد در حلقه‌ها:**

  هنگامی که ما می خواهیم از حلقه استفاده کنیم و متغیر ان برای ما اهمیت ندارد ( متغیر استفاده نمیشود یا نام گذاری ان برای ما مهم نیست) از **(`_`)** استفاده می کنیم.
```py
for _ in range(10)
print(_)
```
- **کاربرد در باز کردن تاپل‌ها (Unpacking Tuples):**
  -  زمانی که یک تابع تاپلی را برمی‌گرداند و شما فقط به بخش‌هایی از آن نیاز دارید، می‌توانید برای عناصری که نمی‌خواهید یا نیاز ندارید، از آندرسکور استفاده کنید.

     - **مثال:** فرض کنید تابعی `("علی", 25, 70)` (نام، سن، وزن) را برمی‌گرداند و شما فقط نام را نیاز دارید. به جای `name, age, weight = ("علی", 25, 70)` و تعریف متغیرهای اضافی `age` و `weight` که هرگز استفاده نمی‌شوند، می‌توانید بنویسید:
      ```python
      name, _, _ = ("علی", 25, 70)
      # حالا فقط name متغیر مفیدی برای شماست.
      ```
  - با این روش، نیازی نیست برای متغیرهای غیرضروری اسامی فکر کنید و کد خواناتر می‌شود.

-   **کاربرد در حالت تعاملی  :**
    -   در کنسول پایتون یا محیط‌های تعاملی مانند PyCharm، **آندرسکور به تنهایی آخرین مقدار ارزیابی شده را در خود ذخیره می‌کند**.
    -   **مثال:**
        ```python
        >>> 8
        8
        >>> _
        8 # مقدار 8 را نشان می‌دهد
        >>> "سلام"
        'سلام'
        >>> x = _
        >>> print(x)
        'سلام' # مقدار "سلام" را نشان می‌دهد
        ```
    -   این قابلیت برای دسترسی سریع به آخرین نتیجه محاسبات مفید است.



## 2. استفاده از یک آندرسکور قبل از اسم (`_variable` یا `_method`)

این حالت برای مشخص کردن اعضای **پروتکتد** (Protected) یا کنترل ایمپورت شدن متغیرها در سطح ماژول استفاده می‌شود.

- **مشخص کردن اعضای پروتکتد در کلاس‌ها:**
    - **تعریف:** یک متغیر یا متد که با یک آندرسکور شروع می‌شود، به صورت **پروتکتد** در نظر گرفته می‌شود. این بدان معناست که از نظر قراردادی، این عضو **فقط باید در داخل همان کلاس و کلاس‌های مشتق شده (وراثت یافته) از آن در دسترس باشد**.
    - **ماهیت قراردادی در پایتون:** پایتون به صورت **واقعی دسترسی به اعضای پروتکتد را محدود نمی‌کند**. یعنی اگر شما یک متغیر `_user_id` را در یک کلاس تعریف کنید، همچنان می‌توانید از بیرون کلاس به آن دسترسی پیدا کرده و آن را چاپ کنید (مثلاً `ali._user_id`).

    - **مثال:**
        ```python
        class User:
            def __init__(self, name, phone):
                self._user_id = "generated_id" # متغیر پروتکتد
                self.name = name                 # متغیر پابلیک
                self.phone = phone               # متغیر پابلیک

        ali = User("علی", "0939...")
        print(ali.name)      # دسترسی به عضو پابلیک - بدون هشدار
        print(ali._user_id)  # دسترسی به عضو پروتکتد - ممکن است IDE هشدار دهد، اما کد اجرا می‌شود
        ```
    - **مقایسه با اعضای پابلیک:** اعضای پابلیک (مانند `self.name` یا `self.phone`) بدون هیچ پیشوندی تعریف می‌شوند و از هر جایی قابل دسترسی هستند.

- **جلوگیری از ایمپورت شدن در سطح ماژول:**
    - هنگامی که یک متغیر در سطح بالای یک ماژول (فایل .py) با یک آندرسکور شروع می‌شود 
    
    مثلاً (`my_internal_var = 10_`)، این متغیر به صورت پیش‌فرض با استفاده از 
    
    `*from module import `ایمپورت نخواهد شد.
    - **مثال:**
        فرض کنید فایل `my_module.py` داریم:
        ```python
        # my_module.py
        _x = 10
        y = 20
        ```
        اگر در فایل دیگری بنویسید `* from my_module import `، فقط `y` ایمپورت می‌شود و `_x` خیر. تلاش برای دسترسی به `_x` خطا خواهد داد.
    - **چگونه می‌توان `_x` را ایمپورت کرد؟** برای اینکه متغیرهای با پیشوند آندرسکور نیز با `import *` ایمپورت شوند، باید آن‌ها را صراحتاً در لیست `__all__` در ماژول خود ذکر کنید.
    - **مثال:**
        ```python
        # my_module.py
        _x = 10
        y = 20
        __all__ = ['_x', 'y'] # با این خط، هر دو _x و y با import * ایمپورت می‌شوند
        ```


## 3. استفاده از یک آندرسکور بعد از اسم (`variable_`)

این حالت زمانی استفاده می‌شود که **می‌خواهید نام یک متغیر یا متد را با یک کلمه کلیدی داخلی پایتون یا تابع Built-in تداخل پیدا نکند**.

*   **حل تداخل نامی:**
    *   پایتون دارای کلمات کلیدی و توابع داخلی بسیاری است (مثل `class`، `max`، `min`، `list` و ...). اگر شما بخواهید یک متغیر را با یکی از این نام‌ها بنامید، مثلاً `min`، پایتون آن تابع داخلی `min()` را بازنویسی می‌کند و دیگر نمی‌توانید از آن به عنوان یک تابع استفاده کنید.
    *   برای جلوگیری از این مشکل، **پیشنهاد می‌شود که یک آندرسکور به انتهای نام اضافه کنید**.
    *   **مثال:**
        ```python
        # تابع داخلی min()
        print(min()) # خروجی: 1

        # تعریف متغیر با نام min_ برای جلوگیری از تداخل
        min_ = 5
        print(min_) # خروجی: 5

        # تابع داخلی min() همچنان قابل استفاده است
        print(min()) # خروجی: 10
        ```
    *   اگر به جای `min_` از `min` استفاده می‌کردید (`min = 5`)، آنگاه تابع `min()` پایتون بازنویسی شده و دیگر به عنوان یک تابع عمل نمی‌کرد.

